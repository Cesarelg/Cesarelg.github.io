<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[exCrt]]></title>
    <url>%2F2019%2F04%2F02%2FexCrt%2F</url>
    <content type="text"><![CDATA[$exCrt$前言十几天前写的板子…然而当时就不会证以及打，只是抄了个板子，今天准备把坑填上。 $Description$给定 $n$ 组非负整数 $a_i, b_i$ ，求解关于 $x$ 的方程组$$\begin{cases} x \equiv b_1\ ({\rm mod}\ a_1)\x \equiv b_2\ ({\rm mod}\ a_2)\\ldots\x \equiv b_n ({\rm mod}\ a_n) \end{cases}$$的最小非负整数解。 $Solution$先从简单的入手，现在有$$\begin{cases} x \equiv b_1\ ({\rm mod}\ a_1)\x \equiv b_2\ ({\rm mod}\ a_2) \end{cases}$$将其转换成$$\begin{cases} x = b_1k_1\x = b_2k_2 \end{cases}$$联立一下，就有$$b1k1 = a_2 - a_1 + b_2k_2$$根据 $exgcd$ 可知，满足有解的条件是 $gcd (b_1, b_2) | (a_2 - a_1)$ 设$$d = gcd(b_1, b_2)$$两边同除以 $d$ ，得$$\frac{b_1}{d}k_1 = \frac{a_2 - a_1}{d} + \frac{b_2}{d}k_2$$两边同时对 $\dfrac{b_2}{d}$ 取模，得$$\frac{b_1}{d}k_1 = \frac{a_2 - a_1}{d} \pmod { \frac{b_2}{d} }$$即$$k_1 \equiv (\frac{b_1}{d})^{-1} \times \frac{a_2 - a_1}{d} \pmod {\frac{b_2}{d}}$$也即$$k_1 = (\frac{b_1}{d})^{-1} \times \frac{a_2 - a_1}{d} + y\frac{b_2}{d}$$带回原式，得$$x = b_1 \times (\frac{b_1}{d})^{-1} \times \frac{a_2 - a_1}{d} + y\frac{b_1b_2}{d} + a_1$$即$$x = b_1 \times (\frac{b_1}{d})^{-1} \times \frac{a_2 - a_1}{d} + y\frac{b_1b_2}{d}$$设 $c = b_1 \times (\dfrac{b_1}{d})^{-1} \times \dfrac{a_2 - a_1}{d}, m = \dfrac{b_1b_2}{d}$ 就做出了这个简单的式子。 然后我们考虑通解。 设已经求出前 $k - 1$ 个方程组成的同余方程组得解为 $Ans$ ， $M = \operatorname{LCM}_{i - 1}^{k - 1}a[i]$ 。 所以前 $k - 1$ 个方程的通解为 $Ans + i * M$ 。 然后我们考虑加入第 $k$ 个方程后的方程组，也就是要我们求$$Ans + Mx \equiv b_k \pmod {a_k}$$也就是求$$Mx \equiv b_k - Ans \pmod {a_k}$$即$$Mx + a_ky = b_k - Ans$$然后我们考虑用 $exgcd$ 求出 $t$ ，重复 $n$ 遍即可。 $Code:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl)#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); i--)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 100011;const ll inf = 0x3f3f3f3f3f3f;ll n, B[N], A[N];namespace IO &#123; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ( '-' ), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;inline ll mul ( ll a, ll b, ll p ) &#123; ll res = 0; for (; b; b &gt;&gt;= 1, a = (a + a) % p) res = (b &amp; 1)? (res + a) % p: res; return res;&#125;inline void exgcd ( ll a, ll b, ll &amp;d, ll &amp;x, ll &amp;y ) &#123; if (b) exgcd ( b, a % b, d, y, x ), y -= a / b * x; else x = 1, y = 0, d = a; return ;&#125;inline ll exCrt() &#123; ll x, y, M = 1, ans = 0; For ( i, 1, n ) &#123; ll b = ((B[i] - ans) % A[i] + A[i]) % A[i]; ll d; exgcd ( M, A[i], d, x, y ); if (b % d) return -1; x = mul ( x, b / d, A[i] ); ans += x * M; M *= A[i] / d, ans = (ans + M) % M; &#125; return (ans % M + M) % M;&#125;int main() &#123;// freopen("testdata (6).in", "r", stdin);// freopen(".out", "w", stdout); n = read(); For ( i, 1, n ) A[i] = read(), B[i] = read(); return wln ( exCrt() ), 0;&#125;/**/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
        <tag>exgcd</tag>
        <tag>Crt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列统计]]></title>
    <url>%2F2019%2F04%2F01%2F%E5%BA%8F%E5%88%97%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[$Sequence$ $Statistics$$Description$给定三个整数 $N,L$ 和 $R$，统计长度在 $1$ 到 $N$ 之间，元素大小都在 $L$ 到 $R$ 之间的单调不降序列的数量，对 $10^6 + 3$ 取模。 $Solution$观察本题，我们会发现如果他是单调上升序列，那么会非常好做，直接 $\sum_{i = 1}^{n} C_{r - l + 1}^{i}$ 就完事了，但这题是单调不降序列，所以，此处有一个经典套路做法，把所有数字加上他自己的下标，转换成求单调不降序列来做。 如此，数的取值范围就是 $[l + 1, r + n]$ 。 然后答案就是有 $r - l + 1$ 个数可选，总共有 $r - l + n$ 个数。 也就是$$Ans = \sum_{i = 1}^{n} C_{r - l + i}^{r - l}$$显然这个东西复杂度是 $O(n)$ 的，所以我们考虑找规律优化。 我们把 $\sum$ 展开$$Ans = C_{r - l + 1}^{r - l} + C_{r - l + 2}^{r - l} \ldots + C_{r - l + n}^{r - l}$$然后我们考虑在前面加一项 $C_{r - l}^{r - l}$ ，就可以用组合数递推通项公式合并了。 最后的答案就是$$C_{r - l + 1 + n}^{r - l} - C_{r - l}^{r - l}$$即$$Ans = C_{r - l + 1 + n}^{r - l} - 1$$就做完了。 $Code:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl)#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); i--)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 1000011;const ll p = 1e6 + 3;const ll inf = 0x3f3f3f3f3f3f;ll T, n, l, r, fac[N + 5];namespace IO &#123; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ( '-' ), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;inline void Init() &#123; fac[0] = 1; For ( i, 1, N ) fac[i] = fac[i - 1] * i % p;&#125;inline ll power ( ll a, ll b ) &#123; ll res = 1; for (; b; b &gt;&gt;= 1, a = a * a % p) res = (b &amp; 1)? res * a % p: res; return res;&#125;inline ll Inv ( ll a, ll p ) &#123; return power ( a, p - 2 ); &#125;inline ll C ( ll n, ll m ) &#123; return n &lt; m? 0: fac[n] * Inv (fac[m], p) % p * Inv (fac[n - m], p) % p;&#125;inline ll Lucas ( ll n, ll m ) &#123; return !m? 1: C (n % p, m % p) * Lucas (n / p, m / p) % p;&#125;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); Init(); T = read(); while ( T-- ) &#123; n = read(), l = read(), r = read();// debug ( (r - l + 1 + n) / p ); wln ( (Lucas ( r - l + 1 + n, r - l + 1 ) - 1 + p) % p ); &#125; return 0;&#125;/*1728257683 297206817 9441266181000002*/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
        <tag>Lucas</tag>
        <tag>经典套路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数三角形]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%95%B0%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[$Counting$ $Delta$$Description$给定一个 $n \times m$ 的网格，请计算三点都在格点上的三角形共有多少个。 $Solution$考虑分类讨论。 首先，我们发现，每个顶点都在格点上的三角形能且只能被一个矩形完全包含，也就是 而下面这个当中的大矩形就是不包含这个下图中的三角形的，只有用红色标出的小矩形才包含。 所以就将问题转化成了求子矩形个数。 显然，长为 $i$ ，宽为 $j$ 的子矩形有 $(m - i + 1) \times (n - j + 1)$ 个。 然后考虑一个子矩形中有多少种可能的三角形个数。 我们考虑固定一个端点，移动其他两个端点： 红色的点表示固定的点，也就是 $A$ 点，绿色的线表示 $B$ 点此时的活动范围，橙色的线表示 $C$ 点此时的活动范围。 显然， $A​$ 点有 $4​$ 种方案， $B​$ 点有 $i - 1​$ 种方案， $C​$ 点有 $j - 1​$ 种方案。 所以方案数就是 $4 \times (i - 1) \times (j - 1)​$ 然后我们考虑处在顶点上的特殊情况，我们钦定 $B$ 与顶点重合。 当 $B$ 与左上角端点重合时， $C$ 就只能在右边的一条边上动，就有 $i - 1$ 种情况。 当 $B$ 与右下角端点重合时， $C$ 就只能在上面的一条边上动，就有 $j - 1$ 种情况。 当 $B​$ 与右上角端点重合时，情况就变得复杂了。 可以发现此时 $A \to B$ 不仅仅经过了左下角与右上角两个端点，还经过了中间的一些格点，手玩一下几个数据可以发现，经过的格点数是 $gcd(i, j) - 1$ 个。 所以，方案个数就是 $(i + 1) \times (j + 1) - 4 - (gcd(i, j) - 1)​$ 。 注意此处图形可以翻转，所以答案要乘二。 所以，对于每个子矩阵，完全覆盖的三角形个数就是$$4 \times (i - 1) \times (j - 1) + 2 \times [(i - 1) + (j - 1) + (i + 1) \times (j + 1) - 4 - (gcd(i, j) - 1)]$$化简后就是$$6 \times i \times j - 2 \times gcd(i, j)$$ $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl)#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); i--)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 100011;const ll inf = 0x3f3f3f3f3f3f;ll m, n, ans = 0; namespace IO &#123; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ( '-' ), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;inline ll gcd ( ll a, ll b ) &#123; return !b? a: gcd (b, a % b); &#125;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); m = read(), n = read(); For ( i, 1, m ) For ( j, 1, n ) ans += ( m - i + 1 ) * ( n - j + 1 ) * ( 6 * i * j - 2 * gcd (i, j) ); return wln (ans), 0;&#125;/*2 276*/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
        <tag>category talk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[exLucas]]></title>
    <url>%2F2019%2F03%2F29%2FexLucas%2F</url>
    <content type="text"><![CDATA[$exLucas$$Description$求$$C_n^m \bmod p$$不保证 $p$ 为质数， $1&lt;=n, m &lt;= 10^{18}$ 。 $Solution$考虑先将 $p$ 质因数分解。$$p = \prod_{i}p_i^{a_i}$$显然 $p_i^{a_i}$ 两两互质，所以只需要分别求出 $C_{n}^{m} \bmod p^k$ ，构造出多个形如 $C_{n}^{m} = b_i \bmod p_i^{a_i} $ 的方程，最后用 $Crt$ 合并求解即可。 然后考虑求$$C_{n}^{m} \bmod p^k$$根据组合数公式$$C_{n}^{m} = \dfrac{n!}{m!(n-m)!}$$由于 $m!$ 与 $(n - m)!$ 中可能含有因子 $p$ ，不能直接求对于 $p^k$ 的逆元，所以考虑先提出 $n!, m!, (n - m)!$ 中的 $p$ ，最后乘回去即可。 也就是$$\dfrac{\dfrac{n!}{p^{k_1}}}{\dfrac{m!}{p^{k_2}} \times \dfrac{(n - m)!}{p^{k_3}}} \times p^{k_1 - k_2 - k_3}$$显然 $\dfrac{m!}{p^{k_2}}, \dfrac{(n - m)!}{p^{k_3}}$ 与 $p^k$ 互质，直接求逆元即可。 之后考虑如何求形如 $\dfrac{n!}{p^{a}} \bmod p^k$ 的式子。 先举个栗子，如果$$n = 23, p = 3, k = 2$$有$$23! = 1 \times 2 \times 3 \ldots \times 23$$提出 $p$ 的所有倍数$$3^{7} \times 7! \times (1 \times 2 \times 4 \times 5 \times 7 \times 8 \ldots)$$可以看出第一部分是 $p^{\left\lfloor\frac{n}{p}\right\rfloor}​$ ，第二部分是 $\left\lfloor\frac{n}{p}\right\rfloor!​$ ，第三部分是 $\prod_{gcd(d, p) = 1}^{n!}d​$ 。 显然第一部分对于答案没有贡献，第二部分递归即可，所以现在还需要解决第三部分。 观察原式可发现$$1 \times 2 \times 4 \times 5 \times 7 \times 8 \equiv 10 \times 11 \times 13 \times 14 \times 16 \times 17 \pmod {p^k}$$显然，在 $\bmod {p^k}$ 意义下，第三部分的每一份乘积全部与 $\prod_{i = 1, gcd(i, p) = 1}^{p^k}$ 同余。 显然，这些部分有 $\frac{n}{p^k}$ 个，所以只需要暴力算出一次互质的，然后快速幂即可。 记住最后要加上不完整的块，也就是例子里的 $19 \times 20 \times 22 \times 23 $ 。 然后我们回到求组合数的过程，提出因子 $p$ ，最后乘上逆元与提出的 $p$ 即可。 对于原问题， $Crt$ 合并即可。 $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl)#define re register#define For(i, j, k) for(re ll i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re ll i = (j); i &gt;= (k); i--)#define Cross(i, j, k) for(re ll i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 100011;const ll inf = 0x3f3f3f3f3f3f;ll n, m, p;namespace IO &#123; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ( '-' ), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;namespace Solve &#123; inline void exgcd ( ll a, ll b, ll &amp;d, ll &amp;x, ll &amp;y ) &#123; if (b) exgcd ( b, a % b, d, y, x ), y -= a / b * x; else d = a, x = 1, y = 0; return ; &#125; inline ll power ( ll a, ll b, ll p ) &#123; ll res = 1; for (; b; b &gt;&gt;= 1, a = a * a % p) res = (b &amp; 1)? res * a % p: res; return res; &#125; inline ll Inv ( ll a, ll p ) &#123; ll d, x, y; exgcd ( a, p, d, x, y ); return (x + p &gt; p)? x: x + p; &#125; // exgcd 求逆元。 inline ll Crt ( ll b, ll mod ) &#123; return b * Inv ( p / mod, mod ) % p * ( p / mod ) % p; &#125; // Crt 合并答案。 inline ll Devide ( ll n, ll p, ll k ) &#123; if (!n) return 1; ll res = 1; For ( i, 2, k ) if (i % p) res = res * i % k; // 计算一次第三部分 res = power ( res, n / k, k ); // 总共有 n / k 次第三部分。 For ( i, 2, n % k ) if (i % p) res = res * i % k; // 第三部分有一点没被乘进去。 return res * Devide ( n / p, p, k ) % k; // 乘上第二部分。 &#125; // 求阶乘。 inline ll C ( ll n, ll m, ll p, ll k ) &#123; if ( n &lt; m ) return 0; ll cnt = 0, a = Devide (n, p, k), b = Devide (m, p, k), c = Devide (n - m, p, k); Cross ( i, n, i / p ) cnt += i / p; Cross ( i, m, i / p ) cnt -= i / p; Cross ( i, n - m, i / p ) cnt -= i / p; return a * Inv (b, k) % k * Inv (c, k) % k * power (p, cnt, k) % k; &#125; // 求组合数。 n! / m!(n - m)! inline ll exLucas () &#123; ll res = 0, temp = p; for (re int i = 2; i * i &lt;= temp; i++) if (temp % i == 0) &#123; ll t = 1; while (temp % i == 0) t *= i, temp /= i; res = (res + Crt ( C(n, m, i, t), t )) % p; &#125; return (temp &gt; 1)? (res + Crt ( C(n, m, temp, temp), temp )) % p: res; &#125; // 分解质因数， Crt 合并答案。 /* t 就是 p^k, i 就是 p 。 */ &#125;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); n = read(), m = read(), p = read(); return wln ( Solve::exLucas () ), 0;&#125;/*157705804463339796 195211 821261150052*/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
        <tag>exgcd</tag>
        <tag>Lucas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迷路]]></title>
    <url>%2F2019%2F03%2F28%2F%E8%BF%B7%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[$Get$ $lost$$Description$1234windy在一个有向图中迷路了。 该有向图有 N 个节点，windy从节点 0 出发，必须恰好在 T 时刻到达节点 N-1。 现给出该有向图，请问总共有多少种不同的路径。 注意：windy不能在某个节点逗留，且通过某有向边的时间严格为给定的时间。 $Solution$先考虑矩阵边权只有 $0/1$ 的情况。 对于这种情况，直接设 $f_1$ 为给定矩阵， $f_n[i][j]$ 表示 $i \to j$ 路径长度为 $n$ 的路径条数。 此时答案就是$$f_n[i][j] = \sum_{k = 1}^{n} f_{n - 1}[i][k] \times f_1[k][j]$$由于矩阵乘法满足结合律，所以有 $f_n = f_{1}^{n}$ 。 然后考虑边权 $w \in [0, 9] \bigcap Z$ 的情况。 我们发现由于此时边权可能大于 $1$ ，所以不能直接转换成矩阵。 由于观察到 $n &lt;= 10$ ，我们可以考虑暴力将每个点拆成 $9$ 个点 ，并按顺序连边。 所以就是如果从 $i \to j$ 上有一条长度为 $w$ 的边，就从 $i$ 的第 $w - 1$ 个点向 $j$ 连一条边。 之后做矩阵快速幂，答案就是 $f[1][n]$ 。 $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl)#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); i--)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll P = 2009;const ll N = 111;const ll inf = 0x3f3f3f3f3f3f;ll n, T;struct Matrix &#123; ll mp[N][N]; Matrix () &#123; memset ( mp, 0, sizeof (mp) ); &#125; friend Matrix operator *( Matrix a, Matrix b ) &#123; Matrix res; For ( i, 1, n * 9 ) For ( k, 1, n * 9 ) For ( j, 1, n * 9 ) res.mp[i][j] = (res.mp[i][j] + a.mp[i][k] * b.mp[k][j]) % P; return res; &#125; friend Matrix operator ^( Matrix a, ll b ) &#123; Matrix res; For ( i, 1, n * 9 ) res.mp[i][i] = 1; for (; b; b &gt;&gt;= 1, a = a * a) res = (b &amp; 1)? res * a: res; return res; &#125;&#125; Ans;namespace IO &#123; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ( '-' ), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); n = read(), T = read(); For ( i, 1, n ) For ( j, 1, 8 ) Ans.mp[i + j * n][i + (j - 1) * n] = 1; For ( i, 1, n ) For ( j, 1, n ) &#123; ll x; scanf ("%1d", &amp;x); if (x) Ans.mp[i][j + (x - 1) * n] = 1; &#125; return wln ( (Ans ^ T).mp[1][n] ), 0;&#125;/*5 301204507105478051202412345852*/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
        <tag>matrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C Looooops]]></title>
    <url>%2F2019%2F03%2F26%2FC-Looooops%2F</url>
    <content type="text"><![CDATA[$C$ $Looooops$$Description$求$$Cx + A \equiv B \pmod {2^k}$$ $Solution$化简本式：$$Cx + 2^{k}y = B - A$$所以：$$a = C, b = 2^k, c = B - A, d = gcd(a, b)$$代入求解即可。 $Code:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl)#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); i--)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 100011;const ll inf = 0x3f3f3f3f3f3f;ll A, B, C, k;namespace IO &#123; inline ll read() &#123; ll x = 0; bool f = 0; char ch = getchar(); for (; !isdigit (ch); ch = getchar()) f ^= (ch == '-'); for (; isdigit (ch); ch = getchar()) x = ( x &lt;&lt; 3 ) + ( x &lt;&lt; 1 ) + ( ch ^ 48 ); return f? -x: x; &#125; inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ( '-' ), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;inline void exgcd ( ll a, ll b, ll &amp;d, ll &amp;x, ll &amp;y ) &#123; if (b) exgcd ( b, a % b, d, y, x ), y -= a / b * x; else d = a, x = 1, y = 0; return ;&#125;int main() &#123;// freopen("c.in", "r", stdin);// freopen("test.out", "w", stdout); while ( cin &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; k &amp;&amp; (A || B || C || k) ) &#123; ll a = C, b = 1ll &lt;&lt; k, c = B - A; ll d, x, y; exgcd ( a, b, d, x, y ); if (c % d) &#123; puts("FOREVER"); continue; &#125; x = x * (c / d); b /= d; x = (x % b + b) % b; wln (x); &#125; return 0;&#125;/*3 3 2 163 7 2 167 3 2 163 4 2 160 0 0 0*/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
        <tag>exgcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Park]]></title>
    <url>%2F2019%2F03%2F26%2FPark%2F</url>
    <content type="text"><![CDATA[$Park$$Description$123456789游乐园里新推出一个游戏——飞机驾驶体验。有*N*-1 个小朋友来玩这个游戏，他们排成长长的一列。这个游戏一共有 M 架“飞机”可供驾驶，每架飞机的使用时间都是有限制的，第 i 架“飞机”的使用时间是 si 分钟。 一开始所有“飞机”都是闲置着的，然后排队等候着的小朋友依次上“飞机”。如果有飞机闲置，则小朋友一定会上去玩(小朋友不会在意飞机使用的时间)；如果同时有多架“飞机”闲置着，小朋友一定会选择标号最小的那架。 现在你带着你的弟弟来到了游乐园，排到了最后一个位置。你想知道你弟弟会在哪架“飞机”上体验。 $Solution$考虑二分弟弟上飞机的时间。 $check$ 函数很好写，只需要将所有的 $s_i$ 在这么长时间内上去几个人算出来就好了。 二分出时间后，取时间减一， $n$ 与时间减一的差就是弟弟在这分钟上去飞机次序。 把所有在这一分钟满足条件的飞机取出，第 $n - res$ 即为答案。 $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl)#define re register#define For(i, j, k) for(re int i = j; i &lt;= k; i++)#define foR(i, j, k) for(re int i = j; i &gt;= k; i--)#define Cros(i, j, k) for(re int i = j; i; i = k)using namespace std;typedef long long ll;const ll N = 100011;const ll inf = 0x3f3f3f3f3f3f3f;/* 二分真**难调。 */ll n, m, s[N];ll t = 1, zz = 0, bei[N];namespace IO &#123; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write ( ll x ) &#123; if ( x &lt; 0 ) x = -x, putchar ('-'); if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar (' '); &#125; inline void wln ( ll x ) &#123; write (x); putchar ('\n'); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x); wln (y); &#125; &#125;using namespace IO;namespace Subtask1 &#123; ll mn = inf; inline void main () &#123; For ( i, 1, m ) s[i] = read(), mn = min ( mn, s[i] ); zz = m; if ( n - 1 &lt;= m ) &#123; wln (n - 1); exit (0); &#125; while (1) &#123; t ++; For ( i, 1, m ) &#123; // debug (t % s[i]); if ( t % s[i] == 0 ) zz++; if ( zz == n ) &#123; wln (i); exit (0); &#125; &#125; &#125; &#125; &#125;namespace Subtask &#123; ll mx = 0, cnt = 0, alb[N]; inline bool check ( ll ss ) &#123; ll res = 0; For ( i, 1, m ) res += ss / s[i] + 1; return res &gt;= n; &#125; inline void main () &#123; For ( i, 1, m ) s[i] = read(), mx = max ( mx, s[i] ); ll l = 1, r = mx * n; while ( l &lt;= r ) &#123; ll Mid = ( l + r ) &gt;&gt; 1; check (Mid)? r = Mid - 1: l = Mid + 1; &#125; // 二分在第几分钟上飞机。// wln (l); ll aa = l, res = 0, ress = 0, albb; For ( i, 1, m ) res += aa / s[i] + 1; For ( i, 1, m ) ress += (aa - 1) / s[i] + 1; albb = n - ress;// debug (ress);// ress -= res; For ( i, 1, m ) if ( aa % s[i] == 0 ) alb[++cnt] = i;// For ( i, 0, cnt - 1 ) wln ( alb[i] ); wln ( alb [albb] ); &#125; &#125;int main () &#123; freopen("park.in", "r", stdin); freopen("park.out", "w", stdout); n = read(), m = read(); // ( n &lt;= 1000000 )? // Subtask1::main (); Subtask::main (); return 0; // Sherry, &#125;/*22 51 2 3 4 5431 51 2 3 4 5332 51 2 3 4 5433 51 2 3 4 51*/]]></content>
      <tags>
        <tag>two points answer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超能粒子炮·改]]></title>
    <url>%2F2019%2F03%2F22%2F%E8%B6%85%E8%83%BD%E7%B2%92%E5%AD%90%E7%82%AE%C2%B7%E6%94%B9%2F</url>
    <content type="text"><![CDATA[$Super$ $Particle$ $Cannon$$Description$求$$\sum_{i = 0}^{k} C_n^i \bmod 2333$$ $Solution$设$$f(n, k) = \sum_{i = 0}^{k} C_n^i$$即$$\sum_{i = 0}^{k}C_{n / p}^{i / p} \times C_{n \% p}^{i \% p}$$数论分块一下，此处将其分成 $k / p$ 个块，许多数字同属一个块，就一起算掉。$$\sum_{i = 0}^{p - 1}C_{n \% p}^{i}C_{n / p}^{0} + \sum_{i = 0}^{p - 1}C_{n \% p}^{i}C_{n / p}^{1} + … + \sum_{i = 0}^{p - 1}C_{n \% p}^{i}C_{n / p}^{k / p - 1} + \sum_{i = 0}^{k \% p}C_{n \% p}^{i}C_{n / p}^{k / p}$$把 $\sum_{i = 0}^{p - 1}C_{n \% p}^{i}$ 提出来$$\sum_{i = 0}^{p - 1}C_{n \% p}^{i} \sum_{i = 0}^{k}C_{n / p}^{i / p - 1}$$也就是$$f(n \% p, p - 1) \times f(n / p, k / p - 1)$$最后一个不完整的块单独处理$$\sum_{i = 0}^{k \% p}C_{n \% p}^{i}$$即$$f(n \% p,k \% p)$$所以$$f(n, k) = f(n \% p, p - 1) \times f(n / p, k / p - 1) + C_{n / p}^{k / p} \times f(n \% p, k \% p)$$预处理组合数，套个 $Lucas$ 就完了。 $Code:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); i--)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll p = 2333;const ll N = 2345;const ll inf = 0x3f3f3f3f3f3f;ll T, n, k, res, C[N + 11][N + 11], f[N + 11][N + 11];namespace IO &#123; inline ll read() &#123; ll x = 0; bool f = 0; char ch = getchar(); for (; !isdigit (ch); ch = getchar()) f ^= (ch == '-'); for (; isdigit (ch); ch = getchar()) x = ( x &lt;&lt; 3 ) + ( x &lt;&lt; 1 ) + ( ch ^ 48 ); return f? -x: x; &#125; inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ( '-' ), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;inline ll Lucas ( ll n, ll m ) &#123; if ( n &lt; m ) return 0; if ( !m || n == m ) return 1; return C[n % p][m % p] * Lucas ( n / p, m / p ) % p;&#125;inline ll F ( ll n, ll k ) &#123; if ( k &lt; 0 ) return 0; if ( !n || !k ) return 1; if ( n &lt; p &amp;&amp; k &lt; p ) return f[n][k]; return ( F (n / p, k / p - 1) * f[n % p][p - 1] % p + Lucas ( n / p, k / p ) * f[n % p][k % p] % p ) % p;&#125;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); f[0][0] = C[0][0] = 1; For ( i, 1, N ) C[i][i] = C[i][0] = f[i][0] = 1; For ( i, 1, N ) For ( j, 1, i - 1 ) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % p; For ( i, 0, N ) For ( j, 1, N ) f[i][j] = ( C[i][j] + f[i][j - 1] ) % p; T = read(); while ( T-- ) n = read(), wln ( F (n, read()) ); return 0;&#125;/*35 510 71145 1432968763*/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
        <tag>Lucas</tag>
        <tag>数论分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Savage]]></title>
    <url>%2F2019%2F03%2F22%2FSavage%2F</url>
    <content type="text"><![CDATA[$Savage$$Description$给出 $n$ 个野人，初始在第 $C_i$ 个洞穴，每个人一年能走 $P_i$ 个洞穴，寿命是 $L_i$ 年，所有人在一个环上走，求最小满足所有人互不碰到的环的长度。 $Solution$由题意得，我们需要使 $C_{i} + P_i \times x \equiv C_j + P_j \times x \bmod M$ $(x &lt;=1, min(L_i, L_j))$ $|$ $x &gt; min(L_i, L_j)$ 无解。 考虑化简式子：$$(P_i - P_j) \times x \equiv C_j - C_i \pmod M$$移项，变成 $exgcd$ 方程组：$$(P_i - P_j) \times x + M \times y = C_j - C_i$$枚举 $M$ ，解方程即可。 $Code:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); i--)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 111;const ll inf = 0x3f3f3f3f3f3f;ll n, mx, C[N], P[N], L[N];namespace IO &#123; inline ll read() &#123; ll x = 0; bool f = 0; char ch = getchar(); for (; !isdigit (ch); ch = getchar()) f ^= (ch == '-'); for (; isdigit (ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); return f? -x: x; &#125; inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ('-'), x = -x; if ( x &gt; 9 ) write (x / 10); putchar (x % 10 | 48); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;inline ll gcd ( ll a, ll b ) &#123; return !b? a: gcd (b, a % b); &#125;inline void exgcd ( ll a, ll b, ll &amp;d, ll &amp;x, ll &amp;y ) &#123; if (b) &#123; exgcd (b, a % b, d, y, x); y -= a / b * x; &#125; else d = a, x = 1, y = 0; return ;&#125;inline bool check ( ll M ) &#123; For ( i, 1, n ) For ( j, i + 1, n ) &#123; ll d, a = P[i] - P[j], b = M, v = C[j] - C[i], x = 0, y = 0, GCD = gcd ( a, b ); if ( v % GCD == 0 ) &#123; a /= GCD, b /= GCD, v /= GCD; exgcd ( a, b, d, x, y ); b = b &lt; 0? -b: b; x = (x * v % b + b) % b; x = !x? x + b: x; if ( x &lt;= min ( L[i], L[j] ) ) return false; &#125; &#125; return 1;&#125;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); n = read(); For ( i, 1, n ) mx = max (mx, C[i] = read()), P[i] = read(), L[i] = read(); for (re int i = mx; ; i++) if ( check (i) ) return wln (i), 0; return 0;&#125;/*31 3 42 7 33 2 16*/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
        <tag>exgcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Multiplicative inverse]]></title>
    <url>%2F2019%2F03%2F22%2FMultiplicative-inverse%2F</url>
    <content type="text"><![CDATA[$linear$ $inverse$ $element$$Descirption$给出 $k$ ，求它的逆元。 $Solution$设$$a \times k + b = p,{b \times inv[b]}\equiv1\pmod p$$变式，得$$b = p - a \times k,{(p - a \times k) \times inv[b]}\equiv1\pmod p$$ 拆括号，得$${p \times inv[b] - a \times k \times inv[b]}\equiv1\pmod p$$即$${-a \times k \times inv[b]}\equiv1\pmod p$$观察$$a \times k + b = p$$两边同是对 $k$ 取模，得$$b = p \bmod k$$故有$$a = p \div k$$代入原式，得$${-(p / k) \times inv[p \bmod k] \times k}\equiv 1 \pmod p$$即$${-(p / k) \times inv[p \bmod k]} \equiv inv[k] \pmod p$$ 也就是$${(p-p / k) \times inv[p \bmod k]} \equiv inv[k] \pmod p$$ $Code:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl#define re register#define For(i, j, k) for(re int i = j; i &lt;= k; i++)#define foR(i, j, k) for(re int i = j; i &gt;= k; i--)using namespace std;typedef long long ll;const ll N = 200011;const ll inf = 0x3f3f3f3f3f3f;ll n, p, f[N];namespace IO &#123; inline ll read() &#123; ll x = 0; bool f = 0; char ch = getchar(); for(; !isdigit( ch ); ch = getchar()) f^=( ch == '-' ); for(; isdigit( ch ); ch = getchar()) x = ( x &lt;&lt; 3 ) + ( x &lt;&lt; 1 ) + ( ch ^ 48 ); return f? -x: x; &#125; inline void write( ll x ) &#123; if( x &lt; 0 ) putchar( '-' ), x = -x; if( x &gt; 9 ) write( x / 10 ); putchar( x % 10 | 48 ); &#125; inline void wln( ll x ) &#123; write( x ); putchar( '\n' ); &#125;&#125;using namespace IO;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); n = read(), p = read(); f[1] = 1; For ( i, 2, n ) f[i] = ( p - p / i ) * f[p % i] % p; For ( i, 1, n ) wln ( f[i] ); return 0;&#125;/**/]]></content>
      <tags>
        <tag>math</tag>
        <tag>Study Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聪明的燕姿]]></title>
    <url>%2F2019%2F03%2F21%2F%E8%81%AA%E6%98%8E%E7%9A%84%E7%87%95%E5%A7%BF%2F</url>
    <content type="text"><![CDATA[$Smart$ $Yanzi$$Description$给你一个数 $S$ ，求有多少数的约数和等于 $S$ 。 $Solution$对于一个数 $S$ ，根据算数基本定理，有分解式：$$S = p_1^{a_1}p_2^{a_2}p_3^{a_3}…p_n^{a_n}$$所以约数和就是$$sum = \prod_{i = 1}^{n}\sum_{j=0}^{a_i}p_i^j$$由于 $S&lt;=2*10^9$ ，考虑枚举 $S$ 的所有因子，先筛出 $\sqrt{S}$ 以内的质数，然后枚举 $p_i$ ，对于每个 $p_i$ 枚举 $a_i$ ，爆搜，如果将 $S$ 分解成功，答案 $ + 1$ 。 同时，如果 $S - 1$ 是一个质数，且 $&gt;=$ 当前搜的 $p_i$ ，答案也要 $ + 1$ ，因为 $S - 1$ 也是此时构造出的数的因子。 其实我们是先把质因子全部取出来，然后找所有的乘起来的可能，对于每种可能都枚举它是否成立。 就是把 $S$ 拆掉，然后再拼回去。 $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); i--)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 100011;const ll inf = 0x3f3f3f3f3f3f;ll S, tot = 0, di[N &lt;&lt; 2];namespace IO &#123; inline ll read() &#123; ll x = 0; bool f = 0; char ch = getchar(); for (; !isdigit (ch); ch = getchar()) f^= (ch == '-'); for (; isdigit (ch); ch = getchar()) x = ( x &lt;&lt; 3 ) + ( x &lt;&lt; 1 ) + ( ch ^ 48 ); return f? -x: x; &#125; inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ( '-' ), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;ll cnt, pr[N], vis[N];inline void Init () &#123; For ( i, 2, N ) &#123; if ( !vis[i] ) pr[++cnt] = i; for ( re int j = 1; j &lt;= cnt &amp;&amp; i * pr[j] &lt;= N; j++ ) &#123; vis[i * pr[j]] = 1; if ( i % pr[j] == 0 ) break; &#125; &#125;&#125; // 预处理质数。 inline bool check ( ll n ) &#123; if ( n == 1 ) return 0; if ( n &lt;= N ) return !vis[n]; for ( re int i = 1; pr[i] * pr[i] &lt;= n; i++ ) if ( n % pr[i] == 0 ) return 0; return 1;&#125; // 判断质数。 inline void dfs ( ll now, ll x, ll y ) &#123; // x 表示当前用到第几个质数，y 表示当前搜出的数。 if ( now == 1 ) &#123; di[++tot] = y; return ; &#125; // 满足答案。 if ( now - 1 &gt;= pr[x] &amp;&amp; check ( now - 1 ) ) di[++tot] = y * ( now - 1 ); /* 如果当前数能表示成一个质数加一与一的乘积，那么就会是答案，只需要将 当前算出的答案乘上它就是满足条件的答案。 */ ll p, temp; for ( re int i = x; pr[i] * pr[i] &lt;= now; i++ ) &#123; temp = pr[i], p = pr[i] + 1; for (; p &lt;= now; temp *= pr[i], p += temp) if ( now % p == 0 ) dfs ( now / p, i + 1, y * temp ); &#125; // 枚举符合题意的因子。&#125;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); Init (); while ( cin &gt;&gt; S ) &#123; tot = 0; memset ( di, 0, sizeof ( di ) ); dfs ( S, 1ll, 1ll ); sort ( di + 1, di + tot + 1 ); // 从小到大输出。 wln (tot); For ( i, 1, tot - 1 ) wrn ( di[i] ); if (tot) wln ( di[tot] ); &#125; return 0;&#125;/*4220 26 41*/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sakura]]></title>
    <url>%2F2019%2F03%2F21%2FSakura%2F</url>
    <content type="text"><![CDATA[$Sakura$$Description$求 $\frac{1}{x} + \frac{1}{y} = \frac{1}{n!}$ 的答案方案个数。 $Solution$设$$x = n! - a, y = n! - b, n = n!$$代入，得$$\frac{2n - a - b}{(n - a)(n - b)} = \frac{1}{n}$$化简，移项，得$$2n^2 - (a + b)n = n^2 - (a + b)n + ab$$故有$$ab = n^2$$筛出 $n^2$ 的因子即可。 $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl#define re register#define For(i, j, k) for(re ll i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re ll i = (j); i &gt;= (k); i--)#define cross(i, k) for(re int i = head[k]; i; i = e[i].next)using namespace std;typedef long long ll;const ll N = 2000011;const ll p = 1e9 + 7;const ll inf = 0x3f3f3f3f3f3f;ll n;namespace IO &#123; inline ll read() &#123; ll x = 0; bool f = 0; char ch = getchar(); for (; !isdigit (ch); ch = getchar()) f^= (ch == '-'); for (; isdigit (ch); ch = getchar()) x = ( x &lt;&lt; 3 ) + ( x &lt;&lt; 1 ) + ( ch ^ 48 ); return f? -x: x; &#125; inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ( '-' ), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125;&#125;using namespace IO;ll ans = 1, cnt, c[N], pr[N], vis[N];inline void Init () &#123; For ( i, 2, n ) &#123; if ( !vis[i] ) vis[i] = pr[++cnt] = i; for ( re int j = 1; j &lt;= cnt &amp;&amp; i * pr[j] &lt;= n; j++ ) &#123; if ( pr[j] &gt; vis[i] ) break; vis[i * pr[j]] = pr[j]; &#125; &#125;&#125;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); n = read(); Init (); For ( i, 1, cnt ) &#123; ll P = pr[i]; for ( re ll j = P; j &lt;= n; j *= P ) c[i] += n / j; c[i] %= p; // 直接分解质因数。 &#125; For ( i, 1, cnt ) ans = ans * (c[i] * 2 + 1) % p; return wln ( ans ), 0;&#125;/*1439*/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Slingshot]]></title>
    <url>%2F2019%2F03%2F18%2FSlingshot%2F</url>
    <content type="text"><![CDATA[$Slingshot$对于本题，我们进行分类讨论： $ 1. $ 对于这种情况，$x \to y$ 包含了 $s \to t$ ，所以此时的选择有两种： ① 先从 $s$ 走到 $x$ ，然后穿到 $y$ ，再从 $y$ 走到 $t$ 。 ② 直接从 $s$ 走到 $t$ 。 然后我们 $yy$ 一下，如何用线段树维护多个 $x \to y$ 只选一个最优的 $x \to y$ 的情况。 显然，这是个线段树维护区间最小值裸题。 所以，由于我们根据 $x$ 端点排序，所以只需要将 ① 情况的路程插入线段树中的 $ y $ 节点的位置即可。 对于这种情况，路程就是$$ti + (s - x) + (y - t)$$在线段树中插入这个东东即可。 $ 2. $ 对于这种情况， $ s \to t $ 包含了 $ x \to y $ 的情况，所以路程就是$$ti + (x - s) + (t - y)$$$ 3. $ 对于这种情况， $ s \to t $ 包含了 $ x $ ，不包含 $ y $ ，所以路程就是$$ti + (s - x) + (t - y)$$$ 4. $ 与 $ 3 $ 同理，只是包含情况反一下，也就是$$ti + (x - s) + (y - t)$$离散化一下，四种情况各建一棵线段树就完了。 $ Code: $123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define debug(x) cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl#define ls(x) (x &lt;&lt; 1)#define rs(x) (x &lt;&lt; 1 | 1)#define mid ((l + r) &gt;&gt; 1)#define re register#define For(i, j, k) for(re int i = j; i &lt;= k; i++)#define foR(i, j, k) for(re int i = j; i &gt;= k; i--)using namespace std;typedef long long ll;const ll N = 200011;const ll inf = 0x3f3f3f3f3f3f3f;ll n, m, cnt, rep[N];struct node &#123; ll x, y, w, id;&#125; p[N];inline bool cmp ( node a, node b ) &#123; return a.x == b.x? a.x &lt; b.y: a.x &lt; b.x; &#125;namespace IO &#123; inline ll read() &#123; ll x = 0; bool f = 0; char ch = getchar(); for (; !isdigit (ch); ch = getchar()) f ^= ( ch == '-' ); for (; isdigit (ch); ch = getchar()) x = ( x &lt;&lt; 1 ) + ( x &lt;&lt; 3 ) + ( ch ^ 48 ); return f? -x: x; &#125; inline void write ( ll x ) &#123; if ( x &lt; 0 ) x = -x, putchar ( '-' ); if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125;&#125;using namespace IO;namespace Segment_Tree &#123; struct Tree &#123; ll mn; &#125; ans[N &lt;&lt; 2]; inline void push_up ( ll p ) &#123; ans[p].mn = min ( ans[ls(p)].mn, ans[rs(p)].mn ); &#125; inline void build ( ll p, ll l, ll r ) &#123; if ( l == r ) &#123; ans[p].mn = inf; return ; &#125; build ( ls(p), l, mid ); build ( rs(p), mid + 1, r ); push_up (p); &#125; inline void Insert ( ll p, ll l, ll r, ll x, ll k ) &#123; if ( l == r ) &#123; ans[p].mn = min ( k, ans[p].mn ); return ; &#125; if ( mid &gt;= x ) Insert ( ls(p), l, mid, x, k ); if ( mid &lt; x ) Insert ( rs(p), mid + 1, r, x, k ); push_up (p); &#125; inline ll Query ( ll p, ll l, ll r, ll ul, ll ur ) &#123; if ( l &gt;= ul &amp;&amp; r &lt;= ur ) return ans[p].mn; if ( mid &gt;= ur ) return Query ( ls(p), l, mid, ul, ur ); else if ( mid &lt; ul ) return Query ( rs(p), mid + 1, r, ul, ur ); else return min ( Query ( ls(p), l, mid, ul, ur ), Query ( rs(p), mid + 1, r, ul, ur ) ); &#125; &#125;using namespace Segment_Tree;ll u, v, w, s, t, _x[N], _y[N];int main () &#123; freopen ("ztn.in", "r", stdin); freopen ("ztn.out", "w", stdout); n = read(), m = read(); For ( i, 1, n ) &#123; u = read(), v = read(), w = read(); p[++cnt].x = u, p[cnt].y = v, p[cnt].w = w, p[cnt].id = 0; _x[cnt] = u, _y[cnt] =v; &#125; For ( i, 1, m ) &#123; s = read(), t = read(); p[++cnt].x = s, p[cnt].y = t, p[cnt].w = 0, p[cnt].id = i; _x[cnt] = s, _y[cnt] =t; rep[i] = abs ( s - t ); &#125; /* -----------------离散化----------------- */ sort ( p + 1, p + cnt + 1, cmp ); sort ( _x + 1, _x + cnt + 1 ); ll len = unique ( _x + 1, _x + cnt + 1 ) - _x - 1; For ( i, 1, cnt ) p[i].x = lower_bound ( _x + 1, _x + len + 1, p[i].x ) - _x; sort ( _y + 1, _y + cnt + 1 ); len = unique ( _y + 1, _y + cnt + 1 ) - _y - 1; For ( i, 1, cnt ) p[i].y = lower_bound ( _y + 1, _y + len + 1, p[i].y ) - _y; /* ---------------------------------- */ /* ----------------分类讨论------------------ */ build ( 1, 1, cnt ); For ( i, 1, cnt ) if ( !p[i].id ) Insert ( 1, 1, cnt, p[i].y, p[i].w -_x[p[i].x] - _y[p[i].y] ); else rep[p[i].id] = min ( rep[p[i].id], Query ( 1, 1, cnt, 1, p[i].y ) + _x[p[i].x] + _y[p[i].y] ); // x -&gt; y 包含 s ，不包含 t 。 build ( 1, 1, cnt ); For ( i, 1, cnt ) if ( !p[i].id ) Insert ( 1, 1, cnt, p[i].y, p[i].w -_x[p[i].x] + _y[p[i].y] ); else rep[p[i].id] = min ( rep[p[i].id], Query ( 1, 1, cnt, p[i].y, cnt ) + _x[p[i].x] - _y[p[i].y] ); // s -&gt; t 包含 x -&gt; y build ( 1, 1, cnt ); foR ( i, cnt, 1 ) if ( !p[i].id ) Insert ( 1, 1, cnt, p[i].y, p[i].w + _x[p[i].x] + _y[p[i].y] ); else rep[p[i].id] = min ( rep[p[i].id], Query ( 1, 1, cnt, p[i].y, cnt ) - _x[p[i].x] - _y[p[i].y] ); // x -&gt; y 包含 t ， 不包含 s 。 build ( 1, 1, cnt ); foR ( i, cnt, 1 ) if ( !p[i].id ) Insert ( 1, 1, cnt, p[i].y, p[i].w + _x[p[i].x] - _y[p[i].y] ); else rep[p[i].id] = min ( rep[p[i].id], Query ( 1, 1, cnt, 1, p[i].y ) - _x[p[i].x] + _y[p[i].y] ); // x -&gt; y 包含 s -&gt; t /* ---------------------------------- */ For ( i, 1, m ) wln ( rep[i] ); return 0;&#125;/*2 30 10 113 8 21 125 220 7*/ 另外，关于循环的问题为什么有两种正序，两种倒序呢？ 让我们再看一遍先前的例图： 前两个正序的： 后两个倒序的： 发现了吗，两者之间的奥秘。 留给读者自行证明。 从前面开始扫，由于 $ y $ 是排过序的，你插入的点就会在 $ s \to t $ 之间，否则有可能在外面，就是不优的，是错的。 题目链接]]></content>
      <tags>
        <tag>category talk</tag>
        <tag>segment tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遥远的国度]]></title>
    <url>%2F2019%2F03%2F15%2F%E9%81%A5%E8%BF%9C%E7%9A%84%E5%9B%BD%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[$A$ $distant$ $country$### $Description$给出一棵树，需要支持换根、区间查询、区间修改等操作。 $Solution$除了换根操作，其他都是树链剖分板子。 对于换根操作，我们考虑先以一号节点为根节点做一次树剖，然后对于换根的操作分类讨论。 接下来以 $ root ​$ 表示目前的根节点， $ x ​$ 表示 $ x ​$ 子树。 $1.​$ $x == root​$ 对于这种情况，根就是全局最小值，直接输出根即可。 $2.$ $x \in root \bigcap root \in 1$ $|$ $x \notin root \bigcap x \ne root \bigcap x \notin (1 \to root)$ 对于这种情况，哪个为根对于 $ x ​$ 子树没有影响，所以直接查询。 $3.$ $x \in (1 \to root)$ 当 $ x $ 在它们所属的链上时，$ x $ 的子树就是除去往 $ root $ 方向的子树以外的所有子树。 所以把这些不去要的节点找出并去掉，就是答案了。 看下图，感性理解一下。 $ Code :$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl#define re register#define For(i, j, k) for(re int i = j; i &lt;= k; i++)#define foR(i, j, k) for(re int i = j; i &gt;= k; i--)using namespace std;typedef long long ll;const ll N = 100011;const ll inf = 0x3f3f3f3f3f3f;ll n, T, ID, lg[N], def[N];struct edge &#123; ll to, next;&#125; e[N &lt;&lt; 1];ll cnt, head[N];inline void add ( ll u, ll v ) &#123; e[++cnt].to = v, e[cnt].next = head[u], head[u] = cnt; e[++cnt].to = u, e[cnt].next = head[v], head[v] = cnt;&#125;namespace IO &#123; inline ll read() &#123; ll x = 0; bool f = 0; char ch = getchar(); for(; !isdigit( ch ); ch = getchar()) f^=( ch == '-' ); for(; isdigit( ch ); ch = getchar()) x = ( x &lt;&lt; 3 ) + ( x &lt;&lt; 1 ) + ( ch ^ 48 ); return f? -x: x; &#125; inline void write( ll x ) &#123; if( x &lt; 0 ) putchar( '-' ), x = -x; if( x &gt; 9 ) write( x / 10 ); putchar( x % 10 | 48 ); &#125; inline void wln( ll x ) &#123; write( x ); putchar( '\n' ); &#125;&#125;using namespace IO;namespace Chain_Tree &#123; ll fa[25][N], dep[N], size[N], Bigson[N]; inline void dfs1 ( ll u, ll fath ) &#123; fa[0][u] = fath; for ( re int i = 1; ( 1 &lt;&lt; i ) &lt;= dep[u]; i++ ) fa[i][u] = fa[i - 1][fa[i - 1][u]]; // 预处理倍增数组。 dep[u] = dep[fath] + 1, size[u] = 1; for ( re int i = head[u]; i; i = e[i].next ) if ( e[i].to != fath ) &#123; ll v = e[i].to; dfs1 ( v, u ); size[u] += size[v]; if ( size[v] &gt; size[Bigson[u]] ) Bigson[u] = v; &#125; &#125; ll tot = 0, id[N], rk[N], top[N]; inline void dfs2 ( ll u, ll now_top ) &#123; id[u] = ++tot, rk[tot] = u, top[u] = now_top; if ( !Bigson[u] ) return ; dfs2 ( Bigson[u], now_top ); for ( re int i = head[u]; i; i = e[i].next ) if ( e[i].to != fa[0][u] &amp;&amp; e[i].to != Bigson[u] ) dfs2 ( e[i].to, e[i].to ); &#125; &#125; // 树剖板子。 using namespace Chain_Tree;namespace Segment_Tree &#123; ll ans[N &lt;&lt; 2], tag[N &lt;&lt; 2]; inline void push_up ( ll p ) &#123; ans[p] = min ( ans[ls(p)], ans[rs(p)] ); &#125; inline void push_down ( ll p ) &#123; if ( tag[p] ) &#123; tag[ls(p)] = tag[rs(p)] = tag[p]; ans[ls(p)] = ans[rs(p)] = tag[p]; tag[p] = 0; &#125; // 修改元素答案为 tag 。 &#125; inline void build ( ll p, ll l, ll r ) &#123; if ( l == r ) &#123; ans[p] = def[rk[l]]; return ; &#125; build ( ls(p), l, mid ); build ( rs(p), mid + 1, r ); push_up (p); &#125; inline void update ( ll p, ll l, ll r, ll ul, ll ur, ll k ) &#123; if ( l &gt;= ul &amp;&amp; r &lt;= ur ) &#123; ans[p] = tag[p] = k; return ; &#125; push_down (p); if ( mid &gt;= ul ) update ( ls(p), l, mid, ul, ur, k ); if ( mid &lt; ur ) update ( rs(p), mid + 1, r, ul, ur, k ); push_up (p); &#125; inline ll query ( ll p, ll l, ll r, ll ul, ll ur ) &#123; if ( l &gt;= ul &amp;&amp; r &lt;= ur ) return ans[p]; push_down (p); ll res = inf; if ( mid &gt;= ul ) res = min ( res, query ( ls(p), l, mid, ul, ur ) ); if ( mid &lt; ur ) res = min ( res, query ( rs(p), mid + 1, r, ul, ur ) ); return res; &#125; &#125;using namespace Segment_Tree;inline void modify ( ll x, ll y, ll k ) &#123; while ( top[x] != top[y] ) &#123; if ( dep[top[x]] &lt; dep[top[y]] ) swap ( x, y ); update ( 1, 1, n, top[id[x]], id[x], k ); x = fa[0][top[x]]; &#125; if ( id[x] &gt; id[y] ) swap ( x, y ); update ( 1, 1, n, id[x], id[y], k );&#125;inline ll Find ( ll x, ll y ) &#123; For ( i, lg[y], 0 ) if ( y &gt;= ( 1 &lt;&lt; i ) ) y -= 1 &lt;&lt; i, x = fa[i][x]; return x;&#125; // 倍增找祖先。 ll u, v;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); n = read(), T = read(); lg[0] = -1; For ( i, 1, n ) lg[i] = lg[i &gt;&gt; 1] + 1; For ( i, 1, n - 1 ) u = read(), add ( u, read() ); For ( i, 1, n ) def[i] = read(); ID = read(); dfs1 ( 1, 0 ); dfs2 ( 1, 1 ); build ( 1, 1, n ); while ( T-- ) &#123; ll opt = read(); switch ( opt ) &#123; case 1: ID = read(); break; case 2: u = read(), v = read(), modify ( u, v, read() ); break; case 3: u = read(); if ( u == ID ) &#123; wln ( ans[1] ); break; &#125; if ( Find ( ID, dep[ID] - dep[u] ) == u ) &#123; v = Find ( ID, dep[ID] - dep[u] - 1 ); ll aa = query ( 1, 1, n, 1, id[v] - 1 ); ll aaa = ( id[u] + size[v] &lt;= n )? query ( 1, 1, n, id[v] + size[v], n ): inf; wln ( min ( aa, aaa ) ); &#125; else wln ( query ( 1, 1, n, id[u], id[u] + size[u] - 1 ) ); // 此处分类讨论三种情况。 &#125; // 重点。 &#125; return 0;&#125;/**/ 题目链接]]></content>
      <tags>
        <tag>Tree chain partition</tag>
      </tags>
  </entry>
</search>
