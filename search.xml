<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[JXOI2018]排序问题]]></title>
    <url>%2F2019%2F06%2F28%2FJXOI2018-%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[$[JXOI]2018$ 排序问题$Description$ $Solution$先解释一下题意。 就是给你一个长度为 $n$ 的序列，然后允许插入 $m$ 个数到这个序列中，这 $m$ 个数的取值范围在 $[l,\ r]$ 之间，然后把这个序列排序，然后生成一个关于 $x_i$ 的编号排列，求使这个编号排列有序的操作次数的期望。 首先样例已经给出了解释，操作次数的期望就是成功概率的倒数。 然后考虑怎么去求出这个概率。 很显然对于一个不重的排列，成功的概率就是 $\dfrac{1}{n!}$ ，期望就是 $n!$ 。而对于一个有重复元素的排列，成功的概率则与单个重复元素的个数相关，显然如果某个元素出现了 $k$ 次，那么概率就会变成 $p \times \dfrac{k!}{n!}$ ，期望就会变成 $\dfrac{E(x)}{k!}$ 。 那么为了使期望最大，我们插入的数字显然要使得新的排列单个元素出现次数最大的最小。 看到最大的最小，就要想到二分。 先来考虑暴力贪心的做法，设置一个 $limit$ ，开一个桶记录最开始每个数的出现次数，然后先将当前出现次数最小的增加上去，最后将出现次数 $&gt; 1$ 的逆元；累乘给 $Ans$ ，注意 $Ans$ 初始为 $(n + m) !$ 。 然后考虑二分答案。 二分新排列的元素的最大出现次数。 贪心的放，然后判断次数是否 $&lt;= mid$ 。 二分出最大出现次数后解一个方程，解出有几个被放到 $L$ ，有几个是 $L - 1$ 。 注意最后要补上不在 $l \to r$ 范围内的重复数字的贡献以及 $l \to r$ 范围内的 $&gt;= L$ 的数字的贡献。 其实也不算很难，只是中间蠢了没想到解方程怎么搞 。 就做完了。 $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include &lt;bits/stdc++.h&gt;#include &lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define lowbit(x) (x &amp; -x)#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; (x) &lt;&lt; endl)#define Set(x, i) memset (x, i, sizeof(x))#define re register#define For(i, j, k) for(re int i = (j), ED = (k); i &lt;= ED; ++i)#define foR(i, j, k) for(re int i = (j), ED = (k); i &gt;= ED; --i)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 200011;const ll M = 1e7 + N;const ll INF = 5e16;const ll P = 998244353;ll fac[M];ll T, n, m, l, r, x[N];namespace IO &#123; inline char gc() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return (p1 == p2) &amp;&amp; (p2 = (p1 = buf) + fread (buf, 1, 100000, stdin), p1 == p2)? EOF: *p1++; &#125; #define dd ch = gc() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = x * 10 + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if (x &lt; 0) putchar ('-'), x = -x; if (x &gt; 9) write (x / 10); putchar (x % 10 | 48); &#125; inline void wrn ( ll x ) &#123; write (x); putchar (' '); &#125; inline void wln ( ll x ) &#123; write (x); putchar ('\n'); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using IO::wln;using IO::read;tr1::unordered_map &lt;ll, ll&gt; mp;inline ll power ( ll a, ll b, ll res = 1 ) &#123; for (; b; b &gt;&gt;= 1, a = a * a % P) res = (b &amp; 1)? res * a % P: res; return res;&#125;inline ll Inv ( ll a ) &#123; return power (a, P - 2); &#125;namespace Subtask1 &#123; inline void main () &#123; while (T--) &#123; ll A = 0; mp.clear(); n = read(), m = read(), l = read(), r = read(); For ( i, 1, n ) ++mp[x[i] = read()]; ll Lim = 0, Ko = m; while (Ko) &#123; for (int i = l; i &lt;= r &amp;&amp; Ko; ++i) if (mp[i] &lt;= Lim) --Ko, ++mp[i]; ++Lim; &#125; ll Ans = fac[n + m]; For ( i, 1, 300 ) Ans = Ans * Inv (fac[mp[i]]) % P; wln (Ans); &#125; exit (0); &#125;&#125;namespace Cesare &#123; ll Ko = 0, tot = 0; ll a[N], b[N], c[N], cnt[N], Cnt[N]; inline int Check ( ll x ) &#123; ll res = Ko * x; For ( i, 1, tot ) if (Cnt[i] &lt; x) res += x - Cnt[i]; // 使元素的出现次数全部 &gt;= x 。 return res &lt; m; // 使修改次数变成 m 时找到那个最平均的 x 。 &#125; void main() &#123; while (T--) &#123; n = read(), m = read(), l = read(), r = read(); Ko = r - l + 1, tot = 0; For ( i, 1, n ) ++mp[a[i] = b[i] = read()]; sort (b + 1, b + n + 1); ll Len = unique (b + 1, b + n + 1) - b - 1; For ( i, 1, Len ) &#123; cnt[i] = mp[b[i]]; if (b[i] &gt;= l &amp;&amp; b[i] &lt;= r) c[++tot] = b[i], Cnt[tot] = cnt[i], --Ko; &#125; ll L = 0, R = n + m; while (L &lt;= R) &#123; ll Mid = (L + R) &gt;&gt; 1; Check (Mid)? L = Mid + 1: R = Mid - 1; &#125; ll CC = Ko, S = 0; For ( i, 1, tot ) if (Cnt[i] &lt; L) ++CC, S += Cnt[i]; ll Ans = fac[n + m]; if (CC * L == S + m) Ans = Ans * power (Inv (fac[L]), CC) % P; // 全部均摊，Δt = 0 else &#123; ll y = L * CC - m - S; // - Δt ll x = (1 - L) * CC + m + S; // + Δt ll N1 = power (Inv (fac[L]), x); ll N2 = power (Inv (fac[L - 1]), y); Ans = Ans * N1 % P * N2 % P; &#125; For ( i, 1, Len ) if (b[i] &lt; l || b[i] &gt; r) Ans = Ans * Inv (fac[cnt[i]]) % P; For ( i, 1, tot ) if (Cnt[i] &gt;= L) Ans = Ans * Inv (fac[Cnt[i]]) % P; wln (Ans); For ( i, 1, Len ) mp[b[i]] = 0; &#125; exit (0); &#125;&#125;inline void Init() &#123; fac[0] = 1; For ( i, 1, M - 5 ) fac[i] = fac[i - 1] * i % P;&#125;int main()&#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); Init(); T = read(); if (T &lt;= 300) Subtask1::main (); return Cesare::main(), 0;&#125;/**/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
        <tag>expectation</tag>
        <tag>probability</tag>
        <tag>two points answer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XOR Partitioning]]></title>
    <url>%2F2019%2F06%2F25%2FXOR-Partitioning%2F</url>
    <content type="text"><![CDATA[$XOR\ Partitioning$$Description$给一个序列，问有多少种方法能够把这个序列分成若干块使得每一块的异或和都相同。答案对 $1e9+7$ 取模。 $Solution$观察本题，可以发现几个性质： 对于两段异或和 $1 - i,\ 1 - j$ ，规定 $i &lt; j$ ，记 $1 - i$ 的异或和为 $s_i$ ，两段异或和相等当且仅当 $s_j == 0$ ，那么显然对于所有 $s_j == 0$ ，只会有选与不选两种情况，即他对答案的贡献为使答案乘 $2$ 。 我们设 $f_i$ 表示异或和为 $s_i$ 的方案数。 那么对于一个异或和，我们可以发现他可以转移到所有异或和为 $0$ 的 $s_i$ 中，首先就有了一种暴力的转移：$$f_i = \sum_{j = 1}^{i} f_j \times (i \to j)\ 中\ 0\ 的个数 \ (s_i == s_j)$$考虑如何优化这个东西。 显然 $i - j$ 中 $0$ 的个数可以通过前缀和来优化，然后我们对于所有满足 $S_i == S_j$ 的条件的考虑一步步去找相邻两个的方案数。 可以记 $g_i$ 表示所有 $f_i$ 的和，记 $Lst_i$ 表示异或和为 $i$ 的上一个编号。 然后就有转移$$f_{s_i} += (Z_i - Z_{Lst_{s_i}}) \times g_{s_i}$$ $$g_{s_i} += f_{s_i}$$ 就是前面的所有 $f_{s_i}$ 都可以转移到当前的 $f_{s_i}$ ，并且要乘上这一个 $i$ 遇上一个之间所有 $0$ 的个数，因为都可以转移到。 然后做前缀和即可。 最后答案需要判断 $f_{s_n}$ 是否为 $0$ ，不为 $0$ 就直接取 $f_{s_n}$ 作为答案。 否则考虑加入后面的没取的 $0$ 造成的贡献，注意最后一个 $0$ 必须取才可以转移。 最后累加所有 $g_i$ 即可。 $Code;$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;bits/stdc++.h&gt;#define Set(x, i) memset (x, i, sizeof x)#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; (x) &lt;&lt; endl)#define R register#define For(i, j, k) for(R int i = (j); i &lt;= (k); ++i)#define foR(i, j, k) for(R int i = (j); i &gt;= (k); --i)#define Cross(i, j, k) for(R int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 500011;const ll INF = 5e16;const ll P = 1e9 + 7;/* 设 f[i] 表示每块异或和为 1 - i 的异或和的方案数。 f[i] = Calc (i)*/ll n, a[N];namespace IO &#123; inline char gc() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return (p1 == p2) &amp;&amp; (p2 = (p1 = buf) + fread (buf, 1, 100000, stdin), p1 == p2)? EOF: *p1++; &#125; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = x * 10 + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write ( ll x ) &#123; if (x &lt; 0) x = -x, putchar ('-'); if (x &gt; 9) write (x / 10); putchar (x % 10 | 48); &#125; inline void wrn ( ll x ) &#123; write (x); putchar (' '); &#125; inline void wln ( ll x ) &#123; write (x); putchar ('\n'); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x); wln (y); &#125; &#125;using IO::wln;using IO::read;ll F = 0, fac[N], inv[N];inline ll power ( ll a, ll b ) &#123; ll res = 1; for (; b; b &gt;&gt;= 1, a = a * a % P) res = (b &amp; 1)? res * a % P: res; return res;&#125;inline ll Inv ( ll x ) &#123; return power (x, P - 2); &#125;inline ll C ( ll n, ll m ) &#123;// debug (fac[n]);// cout &lt;&lt; "!" &lt;&lt; n &lt;&lt; " " &lt;&lt; m &lt;&lt; endl; if (n &lt; m) return 0; if (!m || !n) return 1; return fac[n] * inv [n - m] % P * inv[m] % P;&#125;inline void Init() &#123; fac[0] = 1; For ( i, 1, N - 5 ) fac[i] = fac[i - 1] * i % P; inv[0] = 1; For ( i, 1, N - 5 ) inv[i] = Inv (fac[i]);&#125;namespace Subtask1 &#123; inline void main () &#123; ll Ans = 0; For ( i, 0, n - 1 ) Ans = (Ans + C(n - 1, i)) % P; wln (Ans); exit (0); &#125; &#125;namespace Subtask2 &#123; const ll M = 5011; ll Ans = 0, f[M][1 &lt;&lt; 11], S[N]; inline void main () &#123; For ( i, 1, n ) S[i] = S[i - 1] ^ a[i]; For ( i, 1, n ) &#123; f[i][S[i]] = 1; For ( j, 1, i - 1 ) (f[i][S[i] ^ S[j]] += f[j][S[i] ^ S[j]]) % P; &#125; For ( i, 0, 1024 ) Ans = (Ans + f[n][i]) % P; wln (Ans), exit (0); &#125; &#125;namespace Subtask &#123; const ll M = 1ll &lt;&lt; 20; ll Ans = 1, g[M + 5], f[M + 5], S[M], Lst[M], Z[M]; inline void Add ( ll &amp;a, ll b ) &#123; a = (a + b) &gt; P? a + b - P: a + b; &#125; inline void main () &#123; For ( i, 0, M ) f[i] = 1; For ( i, 1, n ) S[i] = S[i - 1] ^ a[i]; For ( i, 1, n ) Z[i] = Z[i - 1] + (S[i] == 0); For ( i, 1, n ) if (S[i]) &#123; Add (f[S[i]], (Z[i] - Z[Lst[S[i]]]) * g[S[i]] % P); g[S[i]] = (g[S[i]] + f[S[i]]) % P; Lst[S[i]] = i; &#125; if (S[n]) wln (f[S[n]]), exit (0); For ( i, 1, Z[n] - 1 ) Ans = (Ans &lt;&lt; 1) % P; For ( i, 1, M - 1 ) Add (Ans, g[i]); wln (Ans), exit (0); &#125; &#125;int main()&#123; freopen("b.in", "r", stdin); freopen("b.out", "w", stdout); n = read(); Init(); For ( i, 1, n ) a[i] = read(); For ( i, 1, n ) if (a[i]) F = 1; if (!F) Subtask1::main (); if (n &lt;= 5000) Subtask2::main (); else Subtask::main (); return 0;&#125;/*30 0 031 2 3*/ 题目链接]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Norma]]></title>
    <url>%2F2019%2F06%2F20%2FNorma%2F</url>
    <content type="text"><![CDATA[$Norma$ $Description$三种情况。 $1. j \in [mid + 1, p)$ 区间最值就是当前求出来的最值，所以直接累计高斯公式求和就好了。$$min \times max \times \sum_{j = mid + 1}^{p - 1} j - i + 1$$$2. j \in [p, q)$ 区间最大值还是当前的 $max$ ，只是当前的区间最小值变了，因为你的 $j$ 包含了比 $min$ 更小的值。 所以要预处理一个前缀最小值 $mns$ ，并记录 $mns \times j$ 的前缀和 $mnp$ 。 如此可以得到式子$$max \times \sum_{j = p}^{q - 1} mns_j \times (q - p + 1)$$化简得$$max \times \sum_{j = p}^{q - 1} mns_j \times q - max \times \sum_{j = p}^{q - 1} mns_j \times (i - 1)$$$3. j \in [q, r]$ 对于这种情况，区间的最大值和最小值都改变了，所以要处理 $max \times min$ 以及 $max \times min \times j$ 的前缀和，然后再做。 这种情况与第二种情况其实类似，所以记 $max \times min$ 的前缀和为 $mnx$ ， $max \times min \times j$ 的前缀和为 $sum$ ，就有$$max \times \sum_{j = p}^{q - 1} mnx_j \times (q - p + 1)$$一样的化简套路，得$$max \times \sum_{j = p}^{q - 1} mnx_j \times q - max \times \sum_{j = p}^{q - 1} mnx_j \times (i - 1)$$考虑右边区间对于左边的影响，令 $p, q$ 指针单调移动， $CDQ$ 分治即可，复杂度 $O(n\ log\ n)$ 。 $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;bits/stdc++.h&gt;//#include &lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define lowbit(x) (x &amp; -x)#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; (x) &lt;&lt; endl)#define Set(x, i) memset (x, i, sizeof(x))#define R register#define For(i, j, k) for(R int i = (j); i &lt;= (k); ++i)#define foR(i, j, k) for(R int i = (j); i &gt;= (k); --i)#define Cross(i, j, k) for(R int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 500011;const ll INF = 5e16;const ll P = 1e9;ll n, a[N];namespace IO &#123; inline char gc() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return (p1 == p2) &amp;&amp; (p2 = (p1 = buf) + fread (buf, 1, 100000, stdin), p1 == p2)? EOF: *p1++; &#125; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = x * 10 + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if (x &lt; 0) putchar ('-'), x = -x; if (x &gt; 9) write (x / 10); putchar (x % 10 | 48); &#125; inline void wrn ( ll x ) &#123; write (x); putchar (' '); &#125; inline void wln ( ll x ) &#123; write (x); putchar ('\n'); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using IO::wln;using IO::read;namespace Subtask1 &#123; ll Ans = 0; void main () &#123; For ( l, 1, n ) &#123; ll Min = INF, Max = -INF; For ( r, l, n ) &#123; Min = min (Min, a[r]); Max = max (Max, a[r]); Ans = (Ans + Min * Max * (r - l + 1)) % P; &#125; &#125; wln (Ans), exit (0); &#125; &#125;namespace Subtask2 &#123; ll Ans = 0, Mxs[N], Mns[N], Mxp[N], Mnp[N], Mnx[N], Sum[N]; inline void Add ( ll x ) &#123; Ans = (Ans + x) % P; &#125; inline ll S ( ll l, ll r ) &#123; return (l + r) * (r - l + 1) / 2 % P; &#125; inline void CDQ ( ll l, ll r ) &#123; if (l == r) return (void) (Add (a[l] * a[l])); ll Mid = (l + r) &gt;&gt; 1; CDQ (l, Mid); CDQ (Mid + 1, r); ll Min = INF, Max = -INF, p = Mid + 1, q = Mid + 1, i, j; Mxs[Mid] = Mns[Mid] = Mxp[Mid] = Mnp[Mid] = Mnx[Mid] = Sum[Mid] = 0; for (j = Mid + 1; j &lt;= r; ++j) &#123; Min = min (Min, a[j]); Max = max (Max, a[j]); Mns[j] = (Mns[j - 1] + Min) % P; Mxs[j] = (Mxs[j - 1] + Max) % P; Mnp[j] = (Mnp[j - 1] + Min * j) % P; Mxp[j] = (Mxp[j - 1] + Max * j) % P; Mnx[j] = (Mnx[j - 1] + Min * Max) % P; Sum[j] = (Sum[j - 1] + Min * Max % P * j) % P; &#125; // 预处理本段的前缀和。 Min = INF, Max = -INF; for (i = Mid; i &gt;= l; --i) &#123; Min = min (Min, a[i]); Max = max (Max, a[i]); while (p &lt;= r &amp;&amp; Min &lt; a[p]) ++p; while (q &lt;= r &amp;&amp; Max &gt; a[q]) ++q; if (p &lt; q) &#123; Add (Min * Max % P * S(Mid - i + 2, p - i)); Add (Max * (Mnp[q - 1] - Mnp[p - 1] + P) + Max * (Mns[q - 1] - Mns[p - 1] + P) % P * (1 - i + P)); Add (Sum[r] - Sum[q - 1] + (Mnx[r] - Mnx[q - 1] + P) * (1 - i + P) % P); &#125; else &#123; Add (Min * Max % P * S(Mid - i + 2, q - i)); Add (Min * (Mxp[p - 1] - Mxp[q - 1] + P) + Min * (Mxs[p - 1] - Mxs[q - 1] + P) % P * (1 - i + P)); Add (Sum[r] - Sum[p - 1] + (Mnx[r] - Mnx[p - 1] + P) * (1 - i + P) % P); &#125; &#125; &#125; void main () &#123; CDQ (1, n); wln ((Ans + P) % P); exit (0); &#125; &#125;int main()&#123;// freopen("3745.in", "r", stdin);// freopen("3745.out", "w", stdout); n = read(); For ( i, 1, n ) a[i] = read(); if (n &lt;= 3000) Subtask1::main (); else Subtask2::main (); return 0;&#125;/**/ 题目链接]]></content>
      <tags>
        <tag>分治</tag>
        <tag>CDQ 分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[等差子序列]]></title>
    <url>%2F2019%2F06%2F13%2F%E7%AD%89%E5%B7%AE%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[等差子序列$Description$ $Soltuion$权值线段树好题。 先知道一个东西： $a_i &lt;= n\ \&amp;\&amp;\ a_i != a_j$ 首先有一种很显然的 $O(n^2)$ 算法，枚举第一个与第二个，用一个桶记录，直接询问第三个元素是否存在即可。 然后考虑如何优化这个玩意，首先想到枚举第一项，然后优化找第二项与第三项的过程。 好像不太行，考虑把等差数列的式子移个项再做。 有$$a_j - a_i = a_k - a_j$$移项得$$2 \times a_j = a_i + a_k$$然后考虑枚举 $a_j$ ，询问 $a_j - x$ 与 $a_j + x$ 是否在同侧，在异侧就说明找得到这样的等差数列。 考虑用 $Hash + SegmentTree$ 实现这个过程。 我们考虑对于一个序列内有一个数，设他左边有一个 $a_i + x\ (1 &lt;= a_i + x &lt;= n)$ ，那么对于一个数 $a_i - x\ (1 &lt;= a_i - x &lt;= n)$ ，他必然在这个数的左侧或右侧，如果在右侧，那么就找到了一个等差数列，所以我们考虑在左侧寻找这么一个数。 我们用一个状态 $S$ 记录一个数是否在这段区间内出现过，出现过为 $1$ ，没出现为 $0$ 。 然后我们把这一串状态 $Hash$ 起来，从 $1 \to i - 1$ 正着做一遍， $n \to i + 1$ 反着做一遍。如果两段这个元素的哈希值不相同，说明到目前为止这个数一侧的某一个数出现过，另一侧的这个数对应的数没出现，就说明我们找到了一个等差数列。 $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;bits/stdc++.h&gt;#include &lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define lowbit(x) (x &amp; -x)#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; (x) &lt;&lt; endl)#define Set(x, i) memset (x, i, sizeof(x))#define R register#define For(i, j, k) for(R int i = (j); i &lt;= (k); ++i)#define foR(i, j, k) for(R int i = (j); i &gt;= (k); --i)#define Cross(i, j, k) for(R int i = (j); i; i = (k))using namespace std;typedef long long ll;typedef unsigned long long ull;const ll N = 100011;const ll INF = 5e16;ll Q, n, a[N];ull Base = 131, po[N], Ha[N];namespace IO &#123; inline char gc() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return (p1 == p2) &amp;&amp; (p2 = (p1 = buf) + fread (buf, 1, 100000, stdin), p1 == p2)? EOF: *p1++; &#125; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = x * 10 + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if (x &lt; 0) putchar ('-'), x = -x; if (x &gt; 9) write (x / 10); putchar (x % 10 | 48); &#125; inline void wrn ( ll x ) &#123; write (x); putchar (' '); &#125; inline void wln ( ll x ) &#123; write (x); putchar ('\n'); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using IO::wln;using IO::read;inline ull Hash ( ll l, ll r ) &#123; return Ha[r] - Ha[l - 1] * po[r - l + 1];&#125;namespace Segment_Tree &#123; #define ls(x) (x &lt;&lt; 1) #define rs(x) (x &lt;&lt; 1 | 1) #define mid ((l + r) &gt;&gt; 1) struct Tree &#123; ull H1, H2; &#125; T[N &lt;&lt; 2]; inline void pushUp ( ll p, ll l, ll r ) &#123; ll Len = (r - l + 1) &gt;&gt; 1; T[p].H1 = T[ls(p)].H1 * po[Len] + T[rs(p)].H1; T[p].H2 = T[rs(p)].H2 * po[r - l + 1 - Len] + T[ls(p)].H2; &#125; inline void build ( ll p, ll l, ll r ) &#123; if (l == r) return (void) (T[p].H1 = T[p].H2 = 0); build (ls(p), l, mid); build (rs(p), mid + 1, r); pushUp (p, l, r); &#125; inline void Update ( ll p, ll l, ll r, ll x ) &#123; if (l == r) return (void) (T[p].H1 = T[p].H2 = Base); if (mid &gt;= x) Update (ls(p), l, mid, x); if (mid &lt; x) Update (rs(p), mid + 1, r, x); pushUp (p, l, r); &#125; inline ull Query ( ll p, ll l, ll r, ll ul, ll ur ) &#123; if (ul &gt; ur) return 0; if (l &gt;= ul &amp;&amp; r &lt;= ur) return T[p].H1; if (mid &gt;= ur) return Query (ls(p), l, mid, ul, ur); if (mid &lt; ul) return Query (rs(p), mid + 1, r, ul, ur); return Query (ls(p), l, mid, ul, mid) * po[ur - mid] + Query (rs(p), mid + 1, r, mid + 1, ur); &#125; inline ull query ( ll p, ll l, ll r, ll ul, ll ur ) &#123; if (ul &gt; ur) return 0; if (l &gt;= ul &amp;&amp; r &lt;= ur) return T[p].H2; if (mid &gt;= ur) return query (ls(p), l, mid, ul, ur); if (mid &lt; ul) return query (rs(p), mid + 1, r, ul, ur); return query (ls(p), l, mid, ul, mid) + query (rs(p), mid + 1, r, mid + 1, ur) * po[mid - ul + 1]; &#125; &#125; // namespace Segment_Treeusing namespace Segment_Tree;namespace Subtask1 &#123; inline void main () &#123; tr1::unordered_map &lt;ll, ll&gt; Vis, ID; For ( i, 1, n ) Vis[a[i]] = 1, ID[a[i]] = i; For ( i, 1, n ) For ( j, i + 1, n ) if (Vis[a[j] + a[j] - a[i]] &amp;&amp; ID[a[j] + a[j] - a[i]] &gt; j) goto Cesare; puts ("N"); return ; Cesare: puts ("Y"); &#125; &#125; // namespace Subtask1int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); po[0] = 1; For ( i, 1, N - 5 ) po[i] = po[i - 1] * Base; Q = read(); while (Q--) &#123; Set (T, 0); n = read(); For ( i, 1, n ) a[i] = read(); build (1, 1, n); For ( i, 1, n ) &#123; ll Len = min (a[i] - 1, n - a[i]); Update (1, 1, n, a[i]); if (Query (1, 1, n, a[i] - Len, a[i] - 1) != query (1, 1, n, a[i] + 1, a[i] + Len)) goto xzy; &#125; puts ("N"); continue; xzy: puts ("Y"); &#125; return 0;&#125;/**/ 题目链接]]></content>
      <tags>
        <tag>segment tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地精部落]]></title>
    <url>%2F2019%2F05%2F31%2F%E5%9C%B0%E7%B2%BE%E9%83%A8%E8%90%BD%2F</url>
    <content type="text"><![CDATA[地精部落$Description$ $Solution$神仙状态 设 $f_{i, j}$ 表示有 $i$ 个数，开头为 $j$ ，且 $j$ 为山峰的方案数。 首先要知道三个性质：$$对于一个满足条件的数列，其中的两个数\ i\ 与\ i + 1\ ，如果他们不相邻，交换他们的位置，这个数列仍然满足条件。$$ $$对于一个满足条件的数列，将数列中的每个数变为\ n + 1 - this\ ，这个数列的山峰与山谷情况相反，但仍然满足条件。$$ $$对于一个满足条件的数列，把这个数列顺序反一下，仍然满足条件。$$ 然后根据这三个性质，我们把一个数列分两类讨论。 我们把情况分成开头这个 $j$ 与 $j - 1$ 是否相邻来讨论。 对于两者不相邻的情况，根据性质一，我们发现直接交换两个数，把头换成 $j - 1$ 就可以得到一个新的合法的数列，所以可以通过 $f_{i, j - 1}$ 转移到。 对于两者相邻的情况，我们首先可知如果 $j$ 是山峰，那么 $j - 1$ 肯定是山谷，问题转化成有 $i - 1$ 个数，以 $j - 1$ 开头语，且 $j - 1$ 为山谷的方案数， 那么根据性质二，我们首先可以把这个数列转变成 $j - 1$ 为山峰的情况，即每个数变为 $n + 1 - this$ ，然后就可以通过 $f_{i - 1, i - j + 1}$ 转移到了。 所以最后的转移方程就是$$f_{i, j} = f_{i, j - 1} + f_{i - 1, i - j + 1}$$ $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;//#include &lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )#define mid ( (l + r) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; (x) &lt;&lt; endl)#define Set(x, i) memset (x, i, sizeof(x))#define R register#define For(i, j, k) for(R int i = (j); i &lt;= (k); ++i)#define foR(i, j, k) for(R int i = (j); i &gt;= (k); --i)#define Cross(i, j, k) for(R int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll MAXN = 4211;const ll INF = 5e16;ll n, P, H[MAXN];namespace IO &#123; inline char gc() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return (p1 == p2) &amp;&amp; (p2 = (p1 = buf) + fread (buf, 1, 100000, stdin), p1 == p2)? EOF: *p1++; &#125; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = x * 10 + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if (x &lt; 0) putchar ('-'), x = -x; if (x &gt; 9) write (x / 10); putchar (x % 10 | 48); &#125; inline void wrn ( ll x ) &#123; write (x); putchar (' '); &#125; inline void wln ( ll x ) &#123; write (x); putchar ('\n'); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;namespace Subtask1 &#123; ll Ans = 0, Vis[MAXN]; inline void dfs ( ll pos, ll *H ) &#123; if (pos == n + 1) return (void) (++Ans); For ( i, 1, n ) if (!Vis[i]) &#123; if (pos &lt; 2) Vis[i] = 1, H[pos] = i, dfs (pos + 1, H), Vis[i] = 0, H[pos] = 0; else if (H[pos - 2] &lt; H[pos - 1] &amp;&amp; i &lt; H[pos - 1]) Vis[i] = 1, H[pos] = i, dfs (pos + 1, H), Vis[i] = 0, H[pos] = 0; else if (H[pos - 2] &gt; H[pos - 1] &amp;&amp; i &gt; H[pos - 1]) Vis[i] = 1, H[pos] = i, dfs (pos + 1, H), Vis[i] = 0, H[pos] = 0; &#125; &#125; void main () &#123; if (n == 11) wln (707584 % P), exit (0); if (n == 12) wln (5405530 % P), exit (0); if (n == 13) wln (44736512 % P), exit (0); if (n == 14) wln (398721962 % P), exit (0); if (n == 15) wln (3807514624 % P), exit (0); dfs (1, H); wln (Ans * 2 % P); exit (0); &#125;&#125;namespace Subtask &#123; ll f[3][MAXN]; inline void main () &#123; ll Ans = 0; f[0][2] = 1; For ( i, 3, n ) For ( j, 2, i ) f[i &amp; 1][j] = (f[i &amp; 1][j - 1] + f[i - 1 &amp; 1][i - j + 1]) % P; For ( i, 2, n ) Ans = (Ans + f[n &amp; 1][i]) % P; wln (Ans * 2 % P); exit (0); &#125; &#125;int main()&#123;// freopen(".in", "r", stdin);// freopen("test.out", "w", stdout); n = read(), P = read(); if (n &lt;= 15) Subtask1::main (); else Subtask::main (); return 0;&#125;/*7075845405530447365123987219623807514624*/ 题目链接]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[取石子]]></title>
    <url>%2F2019%2F05%2F21%2F%E5%8F%96%E7%9F%B3%E5%AD%90%2F</url>
    <content type="text"><![CDATA[取石子$Description$ $Solution$蛮神仙的一道题。 其实就是 $anti-Nim$ 。 我们约定只有一颗石子的堆叫孤单堆，有多颗石子的堆叫充裕堆。 设 $f_{i, j}$ 表示有 $i$ 个孤单堆，能操作次数为 $j$ 时是 $P-position$ 还是 $N-position$ 。 转移分类讨论，有如下情况： $1.$ 取孤单堆内石子 因为孤单堆只有一个元素，所以取了之后就是 $f_{i - 1, j}$ 这个状态。 $2.$ 把孤单堆内的石子并到充裕堆当中 显然，转移到 $f_{i -1, j + 1}$ ，注意判断此时有无充裕堆，没有的话不能转移。 $3.$ 把孤单堆两个并起来。 此处我们也要考虑两种情况，如果没有充裕堆了，就从 $f_{i - 2, j + 2}$ 转移， 否则从 $f_{i - 2, j + 3}$ 转移过来。因为根据状态的定义，我们合并了两个孤单堆，如果本来有充裕堆，那么我们就多了一次两个充裕堆合并的机会，否则就没有。 $4.$ 把充裕堆石子取出一个 首先我们判断取出后是否变为孤单堆，是的话可以从 $f_{i + 1, j - 2}$ 转移到。 其次，显然还可以从 $f_{i, j - 1}$ 转移到。 一些关于博弈 $dp$ 的看法：分类讨论时，注意一个一个情况来，有条理些，如本题，就是先孤单堆几种情况，再充裕堆的能转移的情况。 $Code:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;//#include &lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; (x) &lt;&lt; endl)#define Set(x, i) memset (x, i, sizeof(x))#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); ++i)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); --i)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 71, M = 50011;const ll inf = 5e16;ll T, n, a[N], f[N][M];namespace IO &#123; inline char gc() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return (p1 == p2) &amp;&amp; (p2 = (p1 = buf) + fread (buf, 1, 100000, stdin), p1 == p2)? EOF: *p1++; &#125; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = x * 10 + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ('-'), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar (' '); &#125; inline void wln ( ll x ) &#123; write (x); putchar ('\n'); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;/* 设 f[i][j] 表示孤单堆有 i 个，充裕堆共有 j 个石子时有无必胜策略。 */inline bool dfs (ll Num, ll Sum) &#123; if (Num &lt;= 0 &amp;&amp; Sum &lt;= 0) return 0; // if (f[Num][Sum] != -1) return f[Num][Sum]; // if (Num &lt;= 0) return f[Num][Sum] = (Sum &amp; 1); // if (Sum == 1) return f[Num][Sum] = dfs (Num + 1, 0); f[Num][Sum] = 0; if (!dfs (Num - 1, Sum)) return f[Num][Sum] = 1; if (Sum &amp;&amp; !dfs (Num, Sum - 1)) return f[Num][Sum] = 1; // if (Sum &amp;&amp; !dfs (Num - 1, Sum + 1)) return f[Num][Sum] = 1; // if (Num &gt;= 2 &amp;&amp; !dfs (Num - 2, Sum + 2 + (Sum? 1: 0))) return f[Num][Sum] = 1; // 一半 return f[Num][Sum];&#125;int main()&#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); Set (f, -1); T = read(); while (T--) &#123; n = read(); ll res = 0, cnt = 0; For (i, 1, n) &#123; a[i] = read(); if (a[i] == 1) ++cnt; if (a[i] &gt; 1) res += a[i] + 1; &#125; res = res? res - 1: res;// debug (res); puts ( dfs (cnt, res)? "YES": "NO" ); &#125; return 0;&#125;/*9971 3 3 3 3 2 2 151 2 1 2 2 */ 题目链接]]></content>
      <tags>
        <tag>game theory</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod B君的游戏]]></title>
    <url>%2F2019%2F05%2F20%2F51nod-B%E5%90%9B%E7%9A%84%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[$B$ 君的游戏$Description$ $Solution$打表好题*2 这道题使我对博弈论打表的理解加深了一些。 首先我们考虑对于一个数所造成的影响，只与他在二进制下 $1$ 的个数有关。 所以状态总数只有 $64$ 种。 我们根据上一题)的经验，可以知道本题的转移就是枚举一个数的所有子集并 $xor$ 起来。 但这题不能直接得到一个局面是否合法，所以需要结合 $SG$ 函数进行求解。 定义 $f(S) = \operatorname{mex}{g(\mathrm{S})}$ 表示最小的不在 $S$ 这个集合当中的自然数。 然后就得到了我们的打表程序。 12345678910111213inline void Init () &#123; For (i, 1, 64) &#123; For (O1, 1, i - 1) For (O2, O1, i - 1) For (O3, O2, i - 1) For (O4, O3, i - 1) For (O5, O4, i - 1) For (O6, O5, i - 1) For (O7, O6, i - 1) &#123; ull A = SG[O1] ^ SG[O2] ^ SG[O3] ^ SG[O4] ^ SG[O5] ^ SG[O6] ^ SG[O7]; Vis[A] = i; &#125; for (int j = 1; ; ++j) if (Vis[j] ^ i) &#123; SG[i] = j; break; &#125; // 暴力求 mex cout &lt;&lt; SG[i] &lt;&lt; ", "; &#125;&#125; 最后，我们异或上所有的一的个数的 $SG$ 值即可。 $Code:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;//#include &lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; (x) &lt;&lt; endl)#define Set(x, i) memset (x, i, sizeof(x))#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); ++i)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); --i)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;typedef unsigned long long ull;const ll N = 100011;const ll inf = 0x3f3f3f3f3f3f;const ll SG[] = &#123; 0, 1, 2, 4, 8, 16, 32, 64, 128, 255, 256, 512, 1024, 2048, 3855, 4096, 8192, 13107, 16384, 21845, 27306, 32768, 38506, 65536, 71576, 92115, 101470, 131072, 138406, 172589, 240014, 262144, 272069, 380556, 524288, 536169, 679601, 847140, 1048576, 1072054, 1258879, 1397519, 2005450, 2097152, 2121415, 2496892, 2738813, 3993667, 4194304, 4241896, 4617503, 5821704, 7559873, 8388608, 8439273, 8861366, 11119275, 11973252, 13280789, 16777216, 16844349, 17102035, 19984054, 21979742&#125;;ull n, res, a[N];namespace IO &#123; inline char gc() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return (p1 == p2) &amp;&amp; (p2 = (p1 = buf) + fread (buf, 1, 100000, stdin), p1 == p2)? EOF: *p1++; &#125; #define dd ch = getchar() inline ull read() &#123; ull x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = x * 10 + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ull x ) &#123; if (x &lt; 0) putchar ('-'), x = -x; if (x &gt; 9) write (x / 10); putchar (x % 10 | 48); &#125; inline void wrn ( ull x ) &#123; write (x); putchar (' '); &#125; inline void wln ( ull x ) &#123; write (x); putchar ('\n'); &#125; inline void wlnn ( ull x, ull y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;inline ll Devide (ll b) &#123; ll res = 0; for (; b; b &amp;= b - 1) ++res; return res;&#125;int main()&#123;// freopen(".in", "r", stdin);// freopen("biao.out", "w", stdout); n = read(); For ( i, 1, n ) res ^= SG[Devide (read())]; return puts ( !res? "L": "B" ), 0;&#125;/*9137153163127255511L*/ 题目链接]]></content>
      <tags>
        <tag>打表</tag>
        <tag>game theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod 小C的游戏]]></title>
    <url>%2F2019%2F05%2F20%2F51nod-%E5%B0%8FC%E7%9A%84%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[小 $C$ 的游戏$Description$ $Solution$打表好题 首先约定 $P-position$ 表示先手必败， $N-position$ 表示先手必胜。 本题并不需要用到 $SG$ 函数等知识，只需要懂得如何对博弈论的局面进行转移即可。 如此就引出了关于博弈论题目的打表技巧。 首先，我们要分析题目中的状态转移条件。 如本题，一个大小为 $n$ 的石子堆可以转移到 $n - 1$ 个石子或者是 $d_i\ (i \in n)$ ，即 $n$ 的所有约数。 所以，我们的打表程序可以先根据题意初始化前面几个状态，然后从小到大依次枚举 $i$ ，然后枚举所有 $i$ 能转移到的状态，判断他是否是 $P-position$ ，如果是那么当前的 $i$ 就为 $N-position$ ，这是根据定理得出的。 之后就根据打表程序找规律即可。 打表代码：12345678inline void Init () &#123; Pd[1] = 0; For (i, 2, N) &#123; if (!Pd[i - 1]) Pd[i] = 1; else for (int j = 2; j &lt;= i / 2; ++j) if (i % j == 0 &amp;&amp; !Pd[i / j]) &#123; Pd[i] = 1; break; &#125; &#125;&#125; 然后我们找规律发现，除了 $2$ 和 $17$ 以外的质数都是 $P-position$ ，除了 $16,\ 34,\ 289$ 以外的合数都是 $N-position$ 。 再特判掉 $1$ ，就做完了。 $Code:$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;//#include &lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; (x) &lt;&lt; endl)#define Set(x, i) memset (x, i, sizeof(x))#define R register#define For(i, j, k) for(R int i = (j); i &lt;= (k); ++i)#define foR(i, j, k) for(R int i = (j); i &gt;= (k); --i)#define Cross(i, j, k) for(R int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 100011;const ll inf = 0x3f3f3f3f3f3f;ll T, n, cnt = 0, m[N];namespace IO &#123; inline char gc() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return (p1 == p2) &amp;&amp; (p2 = (p1 = buf) + fread (buf, 1, 100000, stdin), p1 == p2)? EOF: *p1++; &#125; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = x * 10 + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ('-'), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar (' '); &#125; inline void wln ( ll x ) &#123; write (x); putchar ('\n'); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;inline bool Check (ll n) &#123; for (R int i = 2; i * i &lt;= n; ++i) if (n % i == 0) return 0; return 1;&#125;int main()&#123;// freopen(".in", "r", stdin);// freopen("test.out", "w", stdout); for (T = read(); T; --T) &#123; n = read(); if (n == 1 || n == 16) puts ("NIE"); else if (n == 2 || n == 17) puts ("TAK"); else if (n == 34 || n == 289) puts ("NIE"); else puts (Check (n)? "NIE": "TAK"); &#125; return 0;&#125;/**/ 题目链接]]></content>
      <tags>
        <tag>打表</tag>
        <tag>game theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod B君的竞技场]]></title>
    <url>%2F2019%2F05%2F08%2F51nod-B%E5%90%9B%E7%9A%84%E7%AB%9E%E6%8A%80%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[$B$ 君的竞技场$Description$ $Solution$设 $f_{i, j}$ 表示胜场到 $i$ 场，败场 $j$ 场的概率。$$f_{i, j} = f_{i - 1, j} \times p + f_{i, j - 1} \times (1 - p)$$然后难点就在于输赢的概率怎么求。。。 我开始下意识以为都是 0.5 结果发现答案死活不对，看了题解发现是积分。。。 然后就去学了一下午积分, *** 我们设竞技场人数为 $n$ ，有$$Ans = \lim_{n \to \infty} \sum_{i = 0}^{n - 1} \frac{1}{n} \times E(\frac{i}{n})$$即$$\lim_{n \to \infty} \int_{0}^{n - 1}f(x) \,dx$$就先用递推式得到一个关于 $p$ 的多项式，然后求导。 枚举所有 $f_{x, i}$ 与 $f_{i, y}$ ，求一下关于他们的定积分并累加即可。 可以发现此时所要求的的函数只与 $x^n$ 有关，直接求导公式 $(x^n)^\prime = nx^{n - 1}$ 一套就行了。 $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; (x) &lt;&lt; endl)#define Set(x, i) memset (x, i, sizeof(x))#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); ++i)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); --i)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef double db;typedef long long ll;typedef unsigned long long ull;const ll N = 51;const ll inf = 0x3f3f3f3f3f3f;ll x, y;double Ans = 0;namespace IO &#123; inline char gc() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return (p1 == p2) &amp;&amp; (p2 = (p1 = buf) + fread (buf, 1, 100000, stdin), p1 == p2)? EOF: *p1++; &#125; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ('-'), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar (' '); &#125; inline void wln ( ll x ) &#123; write (x); putchar ('\n'); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;struct Solve &#123; db a[N + 3]; Solve () &#123; Set (a, 0); &#125; friend Solve operator + ( Solve A, Solve B ) &#123; Solve res; For ( i, 0, N ) res.a[i] = A.a[i] + B.a[i]; return res; &#125; friend Solve operator * ( Solve A, Solve B ) &#123; Solve res; For ( i, 0, N ) For ( j, 0, i ) res.a[i] += A.a[i - j] * B.a[j]; return res; &#125; // 多项式板子。 inline void Derivation () &#123; foR ( i, N, 1 ) a[i] = a[i - 1] / i; a[0] = 0; &#125; // 求导逆过程。 inline db Integral () &#123; Derivation (); db Ans = 0; For ( i, 1, N ) Ans += a[i]; return Ans; &#125; // 把所有答案累加即可。 &#125; Win, Lose, f[N + 3][N + 3];int main()&#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); x = read(), y = read(); f[0][0].a[0] = 1; // 没赢没输概率为 1 。 Win.a[0] = 0, Win.a[1] = 1; // 赢一场 +1 。 Lose.a[0] = 1, Lose.a[1] = -1; // 输一场相反。 For ( i, 0, x - 1 ) For ( j, 0, y - 1 ) &#123; if (i) f[i][j] = f[i][j] + f[i - 1][j] * Win; if (j) f[i][j] = f[i][j] + f[i][j - 1] * Lose; &#125; For ( i, 0, y - 1 ) f[x][i] = f[x - 1][i] * Win, Ans += f[x][i].Integral() * x; For ( i, 0, x - 1 ) f[i][y] = f[i][y - 1] * Lose, Ans += f[i][y].Integral() * i; return printf ("%.12lf", Ans), 0;&#125;/**/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
        <tag>integral</tag>
        <tag>expectation</tag>
        <tag>probability</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mo team]]></title>
    <url>%2F2019%2F05%2F07%2FMo-team%2F</url>
    <content type="text"><![CDATA[$MoTeam$莫队是一种暴力算法，用于求解一类区间计数问题。 普通莫队给你一个有 $n$ 个元素的序列， $m$ 个询问，每个询问有 $l,\ r$ ，询问 $l - r$ 这段区间不同数字的出现个数。 先考虑暴力，每次 $l - r$ 循环一次统计答案，复杂度 $\Theta (nm)$ 。 然后考虑优化。 发现可以把每次区间的左右端点记录下来，由已知的信息推出未知的信息。 但复杂度上界并没有改变，还是 $\Theta (nm)$ 。 考虑离线把所有左右端点记录下来，以左端点为第一关键字，右端点为第二关键字排序，如此使得移动次数最少。 还有优化就是按照奇偶性排序，据说快一倍。 给出一种方式： 1234inline bool cmp ( MoTeam a, Moteam b ) &#123; return (a.l / len) ^ (b.l / len)? a.l &lt; b.l: ( (a.l / len &amp; 1)? a.r &lt; b.r: a.r &gt; b.r );&#125; 然后就暴力，根据题目要求更改 $add$ 与 $del$ 函数即可。 给出实现： 1234while ( R &lt; Q[i].r ) add ( a[++R] );while ( R &gt; Q[i].r ) del ( a[R--] );while ( L &lt; Q[i].l ) del ( a[L++] );while ( L &gt; Q[i].l ) add ( a[--L] ); 带修莫队带修莫队顾名思义，就是有单点修改的莫队，此时我们考虑再记一个 $Time$ 表示距离本次查询最近的修改，如果我们莫队改的少了就再改几次，改的多了就改回去，以此来避免修改操作对答案造成的影响。 同时我们多记一个 $Update$ 数组，来存储修改操作，再在问题数组中也记一个 $Time$ 记录当前查询发生在哪次修改之后，然后回答时把序列改成此次修改之后的序列再操作。 其他的就与莫队本身无区别了。 下面给出一道例题的代码 $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; (x) &lt;&lt; endl)#define Set(x, i) memset (x, i, sizeof(x))#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); ++i)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); --i)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;typedef unsigned long long ull;const ll N = 1000011;const ll inf = 0x3f3f3f3f3f3f;ll n, m, len, res, cnt[N], col[N], Ans[N];ll QNum;struct MoTeam &#123; ll l, r, id, Time;&#125; Q[N];inline bool cmp ( MoTeam a, MoTeam b ) &#123; return (a.l / len) ^ (b.l / len)? a.l &lt; b.l: ( (a.r / len) ^ (b.r / len)? ( (a.l / len &amp; 1)? a.r &lt; b.r: a.r &gt; b.r ): a.Time &lt; b.Time );&#125;ll UNum;struct Node &#123; ll x, col;&#125; Up[N];namespace IO &#123; inline char gc() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return (p1 == p2) &amp;&amp; (p2 = (p1 = buf) + fread (buf, 1, 100000, stdin), p1 == p2)? EOF: *p1++; &#125; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ('-'), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar (' '); &#125; inline void wln ( ll x ) &#123; write (x); putchar ('\n'); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;inline void add ( ll x ) &#123; res += !cnt[x]++; &#125;inline void del ( ll x ) &#123; res -= !--cnt[x]; &#125;inline void upd ( ll x, ll i ) &#123; if ( Up[x].x &gt;= Q[i].l ) if ( Up[x].x &lt;= Q[i].r ) del (col[Up[x].x]), add (Up[x].col); swap (col[Up[x].x], Up[x].col);&#125;int main()&#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); n = read(), m = read(); len = pow (n, 2.0 / 3.35); For ( i, 1, n ) col[i] = read(); For ( i, 1, m ) &#123; char opt; cin &gt;&gt; opt; if ( opt == 'Q' ) &#123; ++QNum; Q[QNum].l = read(), Q[QNum].r = read(); Q[QNum].Time = UNum, Q[QNum].id = QNum; &#125; else Up[++UNum].x = read(), Up[UNum].col = read(); &#125; ll L = 1, R = 0, Time = 0; sort (Q + 1, Q + QNum + 1, cmp); For ( i, 1, QNum ) &#123; while ( L &lt; Q[i].l ) del (col[L++]); while ( L &gt; Q[i].l ) add (col[--L]); while ( R &lt; Q[i].r ) add (col[++R]); while ( R &gt; Q[i].r ) del (col[R--]); while ( Time &lt; Q[i].Time ) upd (++Time, i); while ( Time &gt; Q[i].Time ) upd (Time--, i); Ans[Q[i].id] = res; &#125; For ( i, 1, QNum ) wln (Ans[i]); return 0;&#125;/**/ 树上莫队其实就是把莫队求的东西换了一换，核心代码不变。 用于解决求 $x \to y$ 的路径上的问题。 我们考虑有什么东西可以把树上的问题转化到序列上。 这时候就要用到一种东西，欧拉序。 就是访问一个点 $u$ ，把他加进序列，然后遍历他的子树，然后再把他加进序列。 我们维护一个 $st$ 数组和一个 $ed$ 数组， $st_i$ 表示刚访问到点 $i$ 加入序列的时间， $ed_i$ 表示回溯时访问到点 $i$ 的时间。 对于一对 $x,\ y$ 我们钦定 $st_x &lt; st_y$ ，然后分类讨论。 $1.$ $LCA(x, y) = x$ 。 此时 $x$ 是 $y$ 的祖先，即 $x$ 与 $y$ 在同一条链上，所以只需要统计出现过只一次的点即可。 $2.$ $LCA (x, y) \neq x$ 此时 $x,\ y$ 位于不同的子树内，那么我们只需要统计 $ed_x \to st_y$ 这条路径上的点。 注意还要特判 $LCA$ ，因为之前统计的时候并没有算进去，手摸一下就知道了。 就没了，然后就是代码实现问题了。 给出例题完整代码 $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; (x) &lt;&lt; endl)#define Set(x, i) memset (x, i, sizeof(x))#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); ++i)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); --i)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;typedef unsigned long long ull;const ll N = 100011;const ll inf = 0x3f3f3f3f3f3f;ll St[N], Ed[N];ll n, m, len, res, a[N], b[N], P[N], cnt[N], Ans[N];struct MoTeam &#123; ll l, r, id, add;&#125; Q[N];inline bool cmp ( MoTeam a, MoTeam b ) &#123; return (a.l / len) ^ (b.l / len)? a.l &lt; b.l: ( (a.l / len &amp; 1)? a.r &lt; b.r: a.r &gt; b.r );&#125;struct Edge &#123; ll To, Next;&#125; e[N &lt;&lt; 1];ll Cnt = 0, head[N];inline void add ( ll u, ll v ) &#123; e[++Cnt].To = v, e[Cnt].Next = head[u], head[u] = Cnt; e[++Cnt].To = u, e[Cnt].Next = head[v], head[v] = Cnt;&#125;namespace IO &#123; inline char gc() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return (p1 == p2) &amp;&amp; (p2 = (p1 = buf) + fread (buf, 1, 100000, stdin), p1 == p2)? EOF: *p1++; &#125; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ('-'), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar (' '); &#125; inline void wln ( ll x ) &#123; write (x); putchar ('\n'); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;namespace Tree &#123; ll tot = 0, dep[N], f[21][N]; inline void dfs ( ll u, ll fa ) &#123; dep[u] = dep[fa] + 1, P[++tot] = u, St[u] = tot; For ( i, 0, 15 ) f[i + 1][u] = f[i][f[i][u]]; Cross ( i, head[u], e[i].Next ) if ( fa ^ e[i].To ) f[0][e[i].To] = u, dfs (e[i].To, u); P[++tot] = u, Ed[u] = tot; &#125; // 预处理倍增数组、欧拉序， dfs 序。 inline ll LCA ( ll x, ll y ) &#123; if ( dep[x] &lt; dep[y] ) swap (x, y); foR ( i, 16, 0 ) if ( dep[f[i][x]] &gt;= dep[y] ) x = f[i][x]; if ( x == y ) return x; foR ( i, 16, 0 ) if ( f[i][x] ^ f[i][y] ) x = f[i][x], y = f[i][y]; return f[0][x]; &#125; // 倍增求 LCA 。 &#125;using namespace Tree;ll Vis[N];inline void Add ( ll x ) &#123; if ( Vis[x] ) res -= (--cnt[a[x]] == 0); else res += (++cnt[a[x]] == 1); Vis[x] ^= 1;&#125;int main()&#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); ll u, v; n = read(), m = read(); len = pow (n, 2.0 / 3.35); For ( i, 1, n ) a[i] = b[i] = read(); sort (b + 1, b + n + 1); ll Len = unique (b + 1, b + n + 1) - b - 1; For ( i, 1, n ) a[i] = lower_bound (b + 1, b + Len + 1, a[i]) - b; For ( i, 2, n ) u = read(), add ( u, read() ); dfs (1, 0); For ( i, 1, m ) &#123; ll l = read(); ll r = read(), lca = LCA (l, r); if ( St[r] &lt; St[l] ) swap (l, r); if ( l == lca ) Q[i] = (MoTeam) &#123; St[l], St[r], i, 0 &#125;; if ( l != lca ) Q[i] = (MoTeam) &#123; Ed[l], St[r], i, lca &#125;; &#125; ll L = 1, R = 0; sort ( Q + 1, Q + m + 1, cmp ); For ( i, 1, m ) &#123; while ( L &lt; Q[i].l ) Add (P[L++]); while ( L &gt; Q[i].l ) Add (P[--L]); while ( R &lt; Q[i].r ) Add (P[++R]); while ( R &gt; Q[i].r ) Add (P[R--]); if ( Q[i].add ) Add ( Q[i].add ); Ans[Q[i].id] = res; if ( Q[i].add ) Add ( Q[i].add ); &#125; For ( i, 1, m ) wln (Ans[i]); return 0;&#125;/**/ 树上带修莫队就是把树上莫队和带修莫队并起来。 听起来似乎非常高端，代码其实就是以上两份代码的结合。 我们直接进入一道例题分析一波。 这道题要求 $V_i \times \sum_{j = 1}^{cnt[i]} W_j$ ，支持修改，游览点关系是一棵树。 即第 $i$ 种糖果的美味指数乘上所有新奇指数的和。 那么我们就知道 $Add$ 函数怎么写了： 1234inline void Add ( ll x ) &#123; if ( Vis[x] ) res -= W[cnt[a[x]]--] * V[a[x]]; else res += W[++cnt[a[x]]] * V[a[x]]; Vis[x] ^= 1;&#125; 就是模拟时间流逝，如果曾经计入了答案，就把他踢掉，没计入就把他计入，然后根据乘法分配律搞一搞即可。 然后也没什么了，就把上面两份代码并起来魔改一下就好了。 具体看注释。 $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include &lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; (x) &lt;&lt; endl)#define Set(x, i) memset (x, i, sizeof(x))#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); ++i)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); --i)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;typedef unsigned long long ull;const ll N = 200011;const ll inf = 0x3f3f3f3f3f3f;ll Qc = 0, Uc = 0, res = 0;ll n, m, T, len, a[N], V[N], W[N], C[N], cnt[N], Ans[N];struct MoTeam &#123; ll l, r, id, add, Time;&#125; Q[N];struct Update &#123; ll x, k, Last;&#125; Up[N];inline bool cmp ( MoTeam a, MoTeam b ) &#123; return (a.l / len) ^ (b.l / len)? a.l &lt; b.l: ( (a.r / len) ^ (b.r / len)? ( (a.l / len &amp; 1)? a.r &lt; b.r: a.r &gt; b.r ): a.Time &lt; b.Time );&#125;struct Edge &#123; ll To, Next;&#125; e[N &lt;&lt; 1];ll CntE = 0, head[N];inline void add ( ll u, ll v ) &#123; e[++CntE].To = v, e[CntE].Next = head[u], head[u] = CntE; e[++CntE].To = u, e[CntE].Next = head[v], head[v] = CntE;&#125;namespace IO &#123; inline char gc() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return (p1 == p2) &amp;&amp; (p2 = (p1 = buf) + fread (buf, 1, 100000, stdin), p1 == p2)? EOF: *p1++; &#125; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ('-'), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar (' '); &#125; inline void wln ( ll x ) &#123; write (x); putchar ('\n'); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;namespace Tree &#123; ll tot = 0, P[N], St[N], Ed[N], dep[N], f[21][N]; inline void dfs ( ll u, ll fa ) &#123; dep[u] = dep[fa] + 1, P[++tot] = u, St[u] = tot; For ( i, 0, 15 ) f[i + 1][u] = f[i][f[i][u]]; Cross ( i, head[u], e[i].Next ) if ( fa ^ e[i].To ) f[0][e[i].To] = u, dfs (e[i].To, u); P[++tot] = u, Ed[u] = tot; &#125; inline ll LCA ( ll x, ll y ) &#123; if ( dep[x] &lt; dep[y] ) swap (x, y); foR ( i, 16, 0 ) if ( dep[f[i][x]] &gt;= dep[y] ) x = f[i][x]; if ( x == y ) return x; foR ( i, 16, 0 ) if ( f[i][x] ^ f[i][y] ) x = f[i][x], y = f[i][y]; return f[0][x]; &#125; &#125;using namespace Tree;ll Vis[N];inline void Add ( ll x ) &#123; if ( Vis[x] ) res -= W[cnt[a[x]]--] * V[a[x]]; else res += W[++cnt[a[x]]] * V[a[x]]; Vis[x] ^= 1;&#125;inline void Upd ( ll x, ll k ) &#123; if ( !Vis[x] ) a[x] = k; else Add (x), a[x] = k, Add (x);&#125;inline void Modify ( ll id, ll Check ) &#123; if ( Check ) Add (Check); Ans[id] = res; if ( Check ) Add (Check);&#125;int main()&#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); n = read(), m = read(), T = read(); ll u, v; len = pow (n, 2.0 / 3.35); For ( i, 1, m ) V[i] = read(); For ( i, 1, n ) W[i] = read(); For ( i, 2, n ) u = read(), add ( u, read() ); For ( i, 1, n ) C[i] = a[i] = read(); dfs (1, 0); For ( i, 1, T ) &#123; ll Type = read(), x = read(), y = read(); if ( !Type ) Up[++Uc] = (Update) &#123; x, y, C[x] &#125;, C[x] = y; else &#123; ll lca = LCA (x, y); if ( St[x] &gt; St[y] ) swap (x, y); if ( x == lca ) Q[++Qc] = (MoTeam) &#123; St[x], St[y], Qc, 0, Uc &#125;; if ( x != lca ) Q[++Qc] = (MoTeam) &#123; Ed[x], St[y], Qc, lca, Uc &#125;; &#125; &#125; ll L = 1, R = 0, Time = 0; sort (Q + 1, Q + Qc + 1, cmp); For ( i, 1, Qc ) &#123; while ( L &gt; Q[i].l ) Add (P[--L]); while ( L &lt; Q[i].l ) Add (P[L++]); while ( R &gt; Q[i].r ) Add (P[R--]); while ( R &lt; Q[i].r ) Add (P[++R]); while ( Time &lt; Q[i].Time ) ++Time, Upd ( Up[Time].x, Up[Time].k ); // 修改。 while ( Time &gt; Q[i].Time ) Upd ( Up[Time].x, Up[Time].Last ), --Time; // 还原，带修莫队。 Modify ( Q[i].id, Q[i].add ); // 树上莫队特判 LCA 。 &#125; For ( i, 1, Qc ) wln (Ans[i]); return 0;&#125;/**/]]></content>
      <tags>
        <tag>Moteam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod 七星剑]]></title>
    <url>%2F2019%2F05%2F07%2F51nod-%E4%B8%83%E6%98%9F%E5%89%91%2F</url>
    <content type="text"><![CDATA[七星剑$Description$ $Solution$设 $f_i$ 表示镶 $i$ 颗魔法石的期望。$$f_i = C_j + f_{i - 1} + (f_i - f_{i - 1 - Lose[i][j]}) \times (1 - Prod_{i, j})$$ $$f_i \times Prod_{i, j} = C_j + f_{i - 1} - (1 - Prod_{i, j}) \times f_{i - 1 - Lose[i][j]}$$ $$f_i = \frac{C_j + f_{i - 1} - f_{i - 1 - Lose[i][j]} \times (1 - Prod_{i, j})}{Prod_{i, j}}$$ $Code:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; (x) &lt;&lt; endl)#define Set(x, i) memset (x, i, sizeof(x))#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); ++i)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); --i)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;typedef unsigned long long ull;const ll N = 111;const double eps = 1e-7;const double inf = 1e52;ll n, C[N], Lose[11][N];double f[N], Prod[11][N];namespace IO &#123; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ('-'), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar (' '); &#125; inline void wln ( ll x ) &#123; write (x); putchar ('\n'); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;int main()&#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); n = read(); For ( i, 1, 7 ) f[i] = inf; For ( i, 1, n ) C[i] = read(); For ( i, 1, 7 ) For ( j, 1, n ) cin &gt;&gt; Prod[i][j]; For ( i, 1, 7 ) For ( j, 1, n ) cin &gt;&gt; Lose[i][j]; For ( i, 1, 7 ) &#123; ll f = 0; For ( j, 1, n ) f |= Prod[i][j] &gt; eps; if (!f) return puts ("-1"), 0; &#125; For ( i, 1, 7 ) For ( j, 1, n ) &#123; f[i] = min ( f[i], ( f[i - 1] + C[j] - f[i - 1 - Lose[i][j]] * (1.0 - Prod[i][j]) ) / Prod[i][j] ); &#125; return printf ("%.12lf", f[7]), 0;&#125;/**/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
        <tag>expectation</tag>
        <tag>probability</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod 战忽局的手段]]></title>
    <url>%2F2019%2F05%2F05%2F51nod-%E6%88%98%E5%BF%BD%E5%B1%80%E7%9A%84%E6%89%8B%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[战忽局的手段$Description$ $Solution$套路题。 根据期望的线性，我们可以设 $f_i$ 表示 $m$ 次演讲忽悠成了 $i$ 次的概率。$$Ans = \sum f_i$$ $$f_i = f_{i - 1} + (1 - \frac{ f_{i - 1} }{n})$$ 忽悠成 $i - 1$ 次，有 $\dfrac{f_{i - 1}}{n}$ 的概率书被拿过，会失败。 化简就是$$f_i = \frac{n - 1}{n} f_{i - 1} + 1$$上个矩阵优化一下就是 $\Theta(T \log\ n)$ 的了。 转移矩阵就是$$\begin{bmatrix}\frac{n - 1}{n} &amp; 1\\0 &amp; 0\end{bmatrix}$$注意精度，要用 $float128$ ，毒瘤。 $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; (x) &lt;&lt; endl)#define Set(x, i) memset (x, i, sizeof(x))#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); ++i)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); --i)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;typedef __float128 fl;const ll N = 2;const ll inf = 0x3f3f3f3f3f3f;struct Matrix &#123; fl mp[N + 1][N + 1]; Matrix () &#123; Set (mp, 0); &#125; inline void Init ( ll n ) &#123; mp[1][1] = (fl) (n - 1) / n; mp[1][2] = 0, mp[2][1] = mp[2][2] = 1; &#125; friend Matrix operator *( Matrix a, Matrix b ) &#123; Matrix res; For ( i, 1, N ) For ( k, 1, N ) For ( j, 1, N ) res.mp[i][j] += a.mp[i][k] * b.mp[k][j]; return res; &#125; friend Matrix operator ^( Matrix a, ll b ) &#123; Matrix res; For ( i, 1, N ) res.mp[i][i] = 1; for (; b; b &gt;&gt;= 1, a = a * a) res = (b &amp; 1)? res * a: res; return res; &#125;&#125;;ll T, n, m;namespace IO &#123; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ('-'), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar (' '); &#125; inline void wln ( ll x ) &#123; write (x); putchar ('\n'); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;int main()&#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); for (T = read(); T; --T) &#123; n = read(), m = read(); Matrix A; A.Init (n); Matrix Ans = A ^ (m - 1); printf ( "%.12Lf\n", (long double) (Ans.mp[1][1] + Ans.mp[2][1]) ); &#125; return 0;&#125;/*1019 16 1010 13 913 118 146 162 713 61 191.0000000000005.0309665026611.0000000000002.9219631153791.0000000000009.9138399528795.6754726424061.9843750000004.9578769327731.000000000000*/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
        <tag>expectation</tag>
        <tag>probability</tag>
        <tag>matrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod 第K大区间]]></title>
    <url>%2F2019%2F05%2F03%2F51nod-%E7%AC%ACK%E5%A4%A7%E5%8C%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[第 K 大区间$Description$ $Solution$挺妙的一道想法题。 只想到了要离散化去重、桶，二分真的没想到，看了题解发觉十分精妙，便记录一下。 观察数据范围，可以发现要离散化，然后求区间众数，可以考虑用桶。 关键在于如何优化求解第 $k$ 大区间的过程。 可以二分区间众数的值，判断是否有 $&gt;= k$ 个大于 $mid$ 值的区间众数，有的话就满足要求。 这其实就是把本来要求的第 $k$ 大的值 $&gt;=mid$ 转化为有 $k - 1$ 个区间众数值 $&lt;= mid$ ，从而使本题能够二分求解。 同时，在二分答案的过程中，我们用到了尺取法求出区间众数值 $&gt;= mid$ 的区间个数，因为本题所求的东西满足单调性，答案不会减小，因此可以采用尺取法，做到 $\Theta(n)\ Check$ 。 $Code:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; (x) &lt;&lt; endl)#define Set(x, i) memset (x, i, sizeof(x))#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); ++i)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); --i)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;typedef unsigned long long ull;const ll N = 200011;const ll inf = 0x3f3f3f3f3f3f;ll n, k, a[N], b[N]; namespace IO &#123; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ('-'), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar (' '); &#125; inline void wln ( ll x ) &#123; write (x); putchar ('\n'); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;ll Cnt[N];inline bool Check ( ll Limit ) &#123; Set (Cnt, 0); ll res = 0, r = 0; For ( l, 1, n ) &#123; while ( r &lt;= n &amp;&amp; Cnt[a[r]] &lt; Limit ) Cnt[a[++r]]++; // 尺取法。 if ( r &gt; n ) break; res += n - r + 1; --Cnt[a[l]]; &#125; return res &gt;= k;&#125;int main()&#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); n = read(), k = read(); For ( i, 1, n ) a[i] = b[i] = read(); sort (b + 1, b + n + 1); ll len = unique (b + 1, b + n + 1) - b - 1; For ( i, 1, n ) a[i] = upper_bound (b + 1, b + len + 1, a[i]) - b; ll l = 0, r = 1ll &lt;&lt; 30; while ( l &lt; r ) &#123; ll Mid = (l + r + 1) &gt;&gt; 1; Check (Mid)? l = Mid: r = Mid - 1; &#125; return wln (l), 0;&#125;/* */ 题目链接]]></content>
      <tags>
        <tag>two points answer</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51nod 最后的机会]]></title>
    <url>%2F2019%2F04%2F29%2F51nod-%E6%9C%80%E5%90%8E%E7%9A%84%E6%9C%BA%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[$51nod$ 最后的机会$Description$ $Solution$首先可以套路的将把元音字母变成 $-1$ ，辅音字母变成 $2$ ，然后做一遍前缀和，这样只要 $sum_j - sum_{i - 1} &gt;= 0$ 即可判断该字符串满足条件。 然后考虑如何优化这个枚举找最大的 $j - i + 1$ 的过程。 可以发现对于一个 $i$ ，我们只关心距离他最远的满足条件的 $j$ ，所以我们只要每次取出这个 $j$ ，然后对最终长度取 $MAX$ 即可。 如果暴力的取 $j$ ，复杂度是 $\Theta(n^2)$ 的，对于 $2 \times 10^5$ 的数据范围显然不能接受。 我们发现，如果只用取出一个 $sum_j$ ，使他尽可能大，那么我们可以用线段树来优化这个查找的过程。 可以构建一棵维护区间最大值的线段树，然后在线段树上从右往左找第一个满足条件的端点，找到即退出。 注意题目要求最大，所以从右往左找。 $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; (x) &lt;&lt; endl)#define Set(x, i) memset (x, i, sizeof(x))#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); ++i)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); --i)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 200011;const ll inf = 0x3f3f3f3f3f3f;string s;ll Ans = 0, pos = 0, a[N], Sum[N];namespace IO &#123; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ('-'), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar (' '); &#125; inline void wln ( ll x ) &#123; write (x); putchar ('\n'); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;namespace Segment_Tree &#123; ll ans[N &lt;&lt; 2]; inline void pushUp ( ll p ) &#123; ans[p] = max (ans[ls(p)], ans[rs(p)]); &#125; inline void Build ( ll p, ll l, ll r ) &#123; if ( l == r ) return (void) (ans[p] = Sum[l]); Build ( ls(p), l, mid ); Build ( rs(p), mid + 1, r ); pushUp (p); &#125; inline void Query ( ll p, ll l, ll r, ll ul, ll ur, ll k, ll &amp;Ans ) &#123; if ( Ans != -1 ) return ; if ( l &gt;= ul &amp;&amp; r &lt;= ur ) &#123; if ( l == r ) Ans = (ans[p] &gt;= k)? l: Ans; else &#123; if ( ans[rs(p)] &gt;= k ) Query ( rs(p), mid + 1, r, ul, ur, k, Ans ); if ( ans[ls(p)] &gt;= k ) Query ( ls(p), l, mid, ul, ur, k, Ans ); &#125; return ; &#125; if ( mid &lt; ur ) Query ( rs(p), mid + 1, r, ul, ur, k, Ans ); if ( mid &gt;= ul ) Query ( ls(p), l, mid, ul, ur, k, Ans ); &#125; &#125;using namespace Segment_Tree;int main()&#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); cin &gt;&gt; s; For ( i, 0, s.size() - 1 ) a[i + 1] = (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u')? -1: 2; ll n = s.size(); For ( i, 1, n ) Sum[i] = Sum[i - 1] + a[i]; Build (1ll, 1, n); ll Pos; For ( i, 1, n ) &#123; Pos = -1; Query ( 1, 1, n, i, n, Sum[i - 1], Pos ); if ( Pos != -1 ) Ans = max (Ans, Pos - i + 1); &#125;// foR ( i, n, 1 ) For ( j, 1, i )// if ( Sum[i] - Sum[j - 1] &gt;= 0 ) Ans = max (Ans, (ll) i - j + 1);// foR ( i, n, 1 ) For ( j, 1, i ) // if ( Sum[i] - Sum[j - 1] &gt;= 0 &amp;&amp; Ans == i - j + 1 ) ++pos; if ( !Ans ) return puts("No solution"), 0; For ( i, 1, n - Ans + 1 ) if ( Sum[i + Ans - 1] - Sum[i - 1] &gt;= 0 ) ++pos; return wlnn (Ans, pos), 0;&#125;/**/ 题目链接]]></content>
      <tags>
        <tag>two points answer</tag>
        <tag>segment tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gauss]]></title>
    <url>%2F2019%2F04%2F12%2FGauss%2F</url>
    <content type="text"><![CDATA[$Gauss$——浅谈高斯消元方程组的构造 我们以一道题为例： 本题要求求解路径上 $xor$ 的期望值，那么根据期望是线性的套路性质，我们可以考虑求出每一位上为 $1$ 的期望，乘上使用次数就是答案。 所以我们根据这个性质，设 $f_i$ 表示从 $i$ 这一位为 $1$ 的概率。 那么从其他转移过来为 $0$ 的概率是 $f_i$ ，为 $1$ 的概率为 $1 - f_i$ 。 有$$f_i = \frac{\sum_{E(u, v) = 0} f_i + \sum_{E(u, v) = 1} (1 - f_i)}{du_i}$$移个项$$f_i \times du_i - \sum_{E(u, v) = 0} f_i + \sum_{E(u, v) = 1} f_i = \sum_{E(u, v) = 1}$$然后就到了构造高斯消元方程的时候。 也就是我们将高斯消元的系数填入矩阵中，再利用高斯消元求解。 我们将系数直接放入矩阵$$\begin{bmatrix}du_{1_1} - \sum_{E_{1_1}(u, v) = 0} + \sum_{E_{1_1}(u, v) = 1} &amp; du_{1_2} - \sum_{E_{1_2}(u, v) = 0} + \sum_{E_{1_2}(u, v) = 1} &amp; \ldots\\du_{2_1} - \sum_{E_{2_1}(u, v) = 0} + \sum_{E_{2_1}(u, v) = 1} &amp; du_{2_2} - \sum_{E_{2_2}(u, v) = 0} + \sum_{E_{2_2}(u, v) = 1} &amp; \ldots\\\ldots\\du_{n - 1_1} - \sum_{E_{n - 1_1}(u, v) = 0} + \sum_{E_{n - 1_1}(u, v) = 1} &amp; du_{n - 1_2} - \sum_{E_{n - 1_2}(u, v) = 0} + \sum_{E_{n - 1_2}(u, v) = 1} &amp; \ldots\end{bmatrix} =\begin{bmatrix}\sum_{E_1(u, v) = 1}\\\sum_{E_2(u, v) = 1}\\\ldots\\\sum_{E_{n - 1}(u, v) = 1}\end{bmatrix}$$为什么矩阵长成这样？ 因为在本题中，对于每一位，他的状态都不同， $E(u, v)$ 的情况也都不同，所以构造出来了这样的方程。 那么，代码实现就简单了，设 $A_{i, j}$ 表示初始矩阵， $A{i, n + 1}$ 表示答案，对于每一位，我们记一个 $w$ 表示这一位的情况，初始赋值 $A_{u, u} = du_i$ ，如果 $E(u, v) = 0$ 那么 $A_{u, v} - 1$ ，否则 $A_{u, v} + 1$ ，并使 $A_{u, n + 1} + 1$ ，就构造出了高斯消元的矩阵，然后套上模板即可。 特别的， $A_{n, n} = 1$ ， $n \to n$ 的概率是 $1$ 。]]></content>
      <tags>
        <tag>expectation</tag>
        <tag>probability</tag>
        <tag>matrix</tag>
        <tag>gauss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.10 比赛题解]]></title>
    <url>%2F2019%2F04%2F11%2F4-10-%E6%AF%94%E8%B5%9B%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[$4.10$ 比赛部分题解$t1$ 暮色苍然$Descroition$ $Solution$由题意可以列出一点东西：$$\begin{cases}gcd(x, y) = a_1\\gcd(x, y + 1) = a_2\\gcd (x, y + 2) = a_3\\\ldots\\gcd(x, y + l - 1) = a_l\end{cases}$$可以发现$$\begin{cases}a_1|x, a_1 | y\\a_2|x, a_2|(y + 1)\\\ldots\\a_l|x, a_l|(y + l - 1)\end{cases}$$即$$\begin{cases}y \equiv 0 \pmod{a_1}\\y + 1 \equiv 0 \pmod{a_2}\\\ldots\\y + l - 1 \equiv 0 \pmod{a_l}\end{cases}$$$exCrt$ 解方程，判断是否在 $n \times m​$ 范围内即可。 特别的，对于 $k &gt;= m$ 的情况，必然无解。 $t2$ 云外苍天$Description$ $Solution$先考虑没有折返限制的情况。 考虑根据点来 $dp$ ，设 $f[i][j][k]$ 表示从 $i \to j$ 转化了 $2^k$ 的方案数。 转移方程就是$$f[i][j][k] = \sum_{l = 1}^{n} f[i][l][k - 1] \times f[l][j][k - 1]$$跟弗洛伊德十分类似。 显然这个东西可以用矩阵优化。 然后考虑有了折返限制之后怎么搞。 有一个很巧妙的转化：把按点来转移改成按边转移。 然后就做完了。 建图就是先初始化邻接矩阵，然后转移矩阵就是能到 $A$ 的全部赋为 $1$ ，因为可以转移到其他点。 之后因为转移矩阵已经转移过一次了，乘上邻接矩阵的 $T - 1$ 次幂即可。 答案就是最后能到 $B$ 点的全部计入答案。 $t3$ 彼岸归航$Description$ $Solution$显然后面的所有列的状态都与第一列相关，只能是等于第一列或者与第一列完全相反。 所以考虑先搞出第一列，然后慢慢算。 可以将矩阵看成两个 $01$ 串，如果跟第一列相同的是 $0$ ，不同的是 $1$ 。 设 $f[i][j]$ 表示最大连续串长度为 $i$ ，当前连续串长度为 $j$ 的方案数。 转移方程就是$$f[i][j] = \sum_{k = 1}^{min (i, j)} f[i][j - k]$$很好理解，最大连续串长度为 $i$ 的串不可能当前会由连续长度 $i + 1$ 的串转移过来，当前连续串的长度也不可能是负数。 用前缀和优化一下这个东西，就 $O(n^2)$ 了。]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matrix Tree]]></title>
    <url>%2F2019%2F04%2F08%2FMatrix-Tree%2F</url>
    <content type="text"><![CDATA[$Matrix$ $Tree$ $theorem$参考资料 定理1234对于一个无向图 G, 他的生成树个数等于其基尔霍夫矩阵的任意一个 N - 1 阶主子式的行列式的绝对值。N - 1 阶主子式就是对于一个任意的一个 r ，将矩阵的第 r 行和第 r 列同时删去得到的新矩阵。基尔霍夫矩阵的一种求法：K = 度数矩阵 D - 邻接矩阵 A 构造方式度数矩阵 $D$ : 在一个 $N \times N$ 矩阵中 $D[i][i] = i的度数$ ，其余为 $0$ 。 邻接矩阵 $A$ : 在一个 $N \times N$ 矩阵中 $D[i][j] = i \to j 的边数$ ，其余为 $0$ 。 基尔霍夫矩阵 $K = D - A$ 。 行列式求法已求出基尔霍夫矩阵，随意去掉一行一列计算新的行列式，绝对值即生成树个数，有公式$$det(K) = \sum_T(-1)^{\tau(T)}\times K_{1, T_1}\times K_{2, T_2}\times \ldots \times K_{n, T_n}$$复杂度 $O(N\times N!)$ 思考优化求解的方式。 性质$1.$ 互换矩阵两行 （列），行列式变号。证明在参考资料里 $2.$ 矩阵若有两行 （列)完全相同，行列式为 $0$ 。简单说明一下，若有两行（列）都相同，那么可以都被消去，$K[i][i]$ 当中有两个会变 $0$ ，导致行列式归 $0$ 。 也可以通过性质 $1$ 证明，具体看资料 。 $3.$ 如果矩阵的某一行(列)中的所有元素都乘以同一个数k，新行列式的值等于原行列式的值乘上数k。把原求和式每一项提出一个 $k$ 即可。 $ps:$ 推论 如果矩阵的某一行(列)中的所有元素都有一个公因子k，则可以把这个公因子k提到行列式求和式的外面。$4.$ 如果把矩阵的某一行(列)加上另一行(列)的k倍，则行列式的值不变。懒得打证明了，去看资料去 优化求解方式首先，对于一个上（下）三角矩阵，其行列式是 $\prod_{i = 1}^{n}K[i][i]$ ，根据性质四可知，我们可以采用高斯消元的方式把矩阵消成一个上（下）三角矩阵，然后即可直接求解行列式的值。 为什么是这样？ 我们可以观察最初的求和公式，我们发现对于一个上（下）三角矩阵，他的逆序对个数为 $0$ ，所以我们的答案就变成了 $\prod_{i = 1}^{n} K[i][i]$ 。 例题 $Solution$套上矩阵树定理，有$$Sum = \sum_{Tree} \prod_{(u, v)\in E} P_{u, v}$$由题意得$$Ans = Sum \times \prod_{u, v}(1 - P_{u, v})$$把式子拆出来，再设一个 $K[i][j]$$$Ans = Sum \times \prod_{(u, v)\in E}K_{u, v} \times (1 - P_{u, v}) \prod_{(u, v)\notin E}(1 - P_{u, v})$$而答案是$$Ans = Sum \times \prod_{(u, v)\in E}P_{u, v} \prod_{(u, v)\notin E}(1 - P_{u, v})$$所以只要使$$K_{u, v} = \frac{P_{u, v}}{1 - P_{u, v}}$$即可。 然后我们再把 $\prod_{u, v}(1 - P_{u, v})$ 拆出来，剩下的部分通过高消求出行列式，乘积即为答案。 另外，我们发现当 $P_{i, j} = 1$ 时，会输出 $nan$ ，所以如果我们判断 $P_{i, j} = 1$ ，就将 $P_{i, j}$ 减去 $eps$ 。 $Code:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl)#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); i--)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 71;const ll inf = 0x3f3f3f3f3f3f;const double eps = 0.000000001;ll n;double ans = 1, K[N][N];namespace IO &#123; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ( '-' ), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;inline void Gauss () &#123; For ( i, 1, n - 1 ) &#123; ll pos = i; For ( j, i + 1, n - 1 ) if ( fabs ( K[pos][i] - K[j][i] ) &lt;= eps ) pos = i; if ( i != pos ) For ( j, i, n - 1 ) swap ( K[i][j], K[pos][j] ); For ( j, i + 1, n - 1 ) &#123; double t = K[j][i] / K[i][i]; For ( k, i, n - 1 ) K[j][k] -= t * K[i][k]; &#125; if ( fabs (K[i][i]) &lt; eps ) return (void) (ans = 0); &#125; For ( i, 1, n - 1 ) ans *= K[i][i]; // 求行列式的值。 ans = fabs (ans); /* 利用矩阵树定理做生成树计数时， 传统基尔霍夫矩阵中，如果 x -&gt; y 有一条边， 则看做是边权为 1 ，那么就使 K[x][y]--, K[y][x]-- 此处若边权为 w ，正常操作应是 K[x][y] -= w, K[y][x] -= w ， 但前面却直接赋值成 K[x][y] = K[y][x] = w ，因为这样有可能有 正有负，所以用了 fabs 。 */&#125; int main()&#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); double t = 1; n = read(); For ( i, 1, n ) For ( j, 1, n ) scanf ("%lf", &amp;K[i][j]); For ( i, 1, n ) For ( j, 1, n ) &#123; if ( fabs ( K[i][j] ) &lt; eps ) K[i][j] = eps; if ( fabs ( 1.0 - K[i][j] ) &lt; eps ) K[i][j] = 1 - eps; if ( i &lt; j ) t *= (1.0 - K[i][j]); K[i][j] /= (1.0 - K[i][j]); &#125; For ( i, 1, n ) K[i][i] = 0; For ( i, 1, n ) For ( j, 1, n ) K[i][i] -= (i == j)? 0: K[i][j]; Gauss (); return printf ("%.7lf", ans * t), 0;&#125;/**/]]></content>
      <tags>
        <tag>math</tag>
        <tag>matrix tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[freeway]]></title>
    <url>%2F2019%2F04%2F08%2Ffreeway%2F</url>
    <content type="text"><![CDATA[$freeway$$ps:$ 有点毒的线段树加概率期望，感觉大致有点理解了概率期望的含义，跟平均数有点像？计数就是把所有答案的和除以方案个数。 还有一个小套路？下面讲。 $Description$ $Solution$区间求和，区间查询，显然是线段树题。 然后我们考虑如何进行区间查询。 先考虑求 $l \to r$ 的花费，用一个前缀和数组 $sum$ 记一下，显然花费就是 $sum_r - sum_{l + 1}$ 。 所以期望就是$$\dfrac{\sum_{i = l}^{r}\sum_{j = i}^{r}(sum_j - sum_i)}{C_{r - l + 1}^{2}}$$然后我们考虑如何求出上面这个式子。 分母显然就是 $(r - l + 1) \times (r - l) / 2$ ，然后我们考虑如何求分子。 然后就用到一个推导套路 (?) ，对于区间 $[l, r]$ ，考虑枚举区间内每个数被包含了多少次。 比如$$l \in [l, l], [l, l + 1] \ldots ,[l, r]$$所以分子就是$$\sum_{i = l}^{r}a_i \times (r - i + 1) \times (i - l + 1)$$然后把他拆开，再化简$$\sum_{i = l}^{r}a_i\times(i\times(l + r) + (-i^2) + (r - l + 1 - rl))$$即$$\sum_{i = l}^{r}a_i\times(r - l + 1 - rl) + \sum_{i = l}^{r}i \times (l + r) + \sum_{i = l}^{r}(-i^2)$$线段树维护 $\sum_{i = l}^{r}a_i, \sum_{i = l}^{r}a_i \times i, \sum_{i = l}^{r} \times a_i \times i^2$ 这三个东西就好了。 然后考虑如何维护。 假如现在对于一段区间加上一个 $v$ ，那么$$sum_1 += (r - l + 1) \times v$$ $$sum_2 += ((l + r) \times (r - l + 1) / 2) \times v$$ $$sum_3 += \frac{r(r + 1)(2r + 1) - l(l - 1)(2l - 1)}{6} \times v$$ 线段树即可。 $ps:$ 第三个就是用到了求 $\sum_{i = 1}^{n}i^2$ 的公式，即 $\dfrac{n(n + 1)(2n + 1)}{6}$ 。 $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl)#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); i--)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 100011;const ll inf = 0x3f3f3f3f3f3f;ll n, T;namespace IO &#123; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ( '-' ), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( '/' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;inline ll gcd ( ll a, ll b ) &#123; return !b? a: gcd ( b, a % b ); &#125;namespace Segment_Tree &#123; struct Tree &#123; ll tag, sum[6]; Tree() &#123; memset ( sum, 0, sizeof (sum) ); &#125; &#125; ans[N &lt;&lt; 2]; inline void push_up ( ll p ) &#123; For ( i, 4, 5 ) ans[p].sum[i] = ans[ls(p)].sum[i] + ans[rs(p)].sum[i]; &#125; inline void pushUp ( ll p ) &#123; For ( i, 1, 3 ) ans[p].sum[i] = ans[ls(p)].sum[i] + ans[rs(p)].sum[i]; &#125; inline void pushDown ( ll p, ll l, ll r ) &#123; if ( ans[p].tag ) &#123; ans[rs(p)].tag += ans[p].tag; ans[ls(p)].tag += ans[p].tag, ans[rs(p)].sum[1] += (r - mid) * ans[p].tag; ans[ls(p)].sum[1] += (mid - l + 1) * ans[p].tag; ans[ls(p)].sum[2] += ans[ls(p)].sum[4] * ans[p].tag; ans[rs(p)].sum[2] += ans[rs(p)].sum[4] * ans[p].tag; ans[ls(p)].sum[3] += ans[ls(p)].sum[5] * ans[p].tag; ans[rs(p)].sum[3] += ans[rs(p)].sum[5] * ans[p].tag; ans[p].tag = 0; &#125; &#125; inline void build ( ll p, ll l, ll r ) &#123; if ( l == r ) return (void) (ans[p].sum[4] = l, ans[p].sum[5] = l * l); build ( ls(p), l, mid ); build ( rs(p), mid + 1, r ); push_up (p); &#125; inline void Update ( ll p, ll l, ll r, ll ul, ll ur, ll k ) &#123; if ( l &gt;= ul &amp;&amp; r &lt;= ur ) return (void) (ans[p].tag += k, ans[p].sum[1] += (r - l + 1) * k, ans[p].sum[2] += ans[p].sum[4] * k, ans[p].sum[3] += ans[p].sum[5] * k); pushDown ( p, l, r ); if ( mid &gt;= ul ) Update ( ls(p), l, mid, ul, ur, k ); if ( mid &lt; ur ) Update ( rs(p), mid + 1, r, ul, ur, k ); pushUp (p); &#125; inline Tree Query ( ll p, ll l, ll r, ll ul, ll ur ) &#123; if ( l &gt;= ul &amp;&amp; r &lt;= ur ) return ans[p]; Tree res; if ( ans[p].tag ) pushDown ( p, l, r ); if ( mid &gt;= ul ) &#123; Tree Ans = Query ( ls(p), l, mid, ul, ur ); res.sum[1] += Ans.sum[1], res.sum[2] += Ans.sum[2], res.sum[3] += Ans.sum[3]; &#125; if ( mid &lt; ur ) &#123; Tree Ans = Query ( rs(p), mid + 1, r, ul, ur ); res.sum[1] += Ans.sum[1], res.sum[2] += Ans.sum[2], res.sum[3] += Ans.sum[3]; &#125; return res; &#125; &#125;using namespace Segment_Tree;string opt;ll x, y, k;int main() &#123;// freopen("2752.in", "r", stdin);// freopen("2752.out", "w", stdout); n = read(), T = read(); build ( 1, 1, n ); while ( T-- ) &#123; cin &gt;&gt; opt; x = read(), y = read(); switch ( opt[0] ) &#123; case 'C': k = read(); if ( x == y ) break; Update ( 1, 1, n, x + 1, y, k ); break; case 'Q': Tree res = Query ( 1, 1, n, x + 1, y ); ll fz = (y - (x + 1) - (x + 1) * y + 1) * res.sum[1] + (x + y + 1) * res.sum[2] - res.sum[3]; ll fm = (y - x + 1) * (y - x) &gt;&gt; 1; ll d = gcd ( fz, fm );// debug (d); wlnn ( fz / d, fm / d ); break; &#125; &#125; return 0;&#125;/*4 5C 1 4 2C 1 2 -1Q 1 2Q 2 4Q 1 41/18/317/6*/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
        <tag>expectation</tag>
        <tag>probability</tag>
        <tag>segment tree</tag>
        <tag>经典套路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rabbit Exercise]]></title>
    <url>%2F2019%2F04%2F07%2FRabbit-Exercise%2F</url>
    <content type="text"><![CDATA[$Rabbit$ $Exercise$$Description$ $Solution$又是一道经典套路题。 首先考虑 $50pts$ 的做法。 可以发现跳到左边的贡献是 $2\times c_{j - 1} - c_j$ ，右边的贡献 $2\times c_{j + 1} - c_j$ ，所以期望就是$$\frac{(2 \times c_{j - 1} + 2 \times c_{j + 1} - 2 \times c_j)}{2}$$即$$c_{j - 1} + c_{j + 1} - c_j$$所以暴力就是做 $mk$ 次这个东西即可。 然后考虑正解。 此时，就要用到一种经典套路。 我们考虑先做一次差分，设$$f_i = a_i - a_{i - 1}$$然后我们发现，把 $c_j$ 插到 $c_{j - 1}$ 与 $c_{j +1}$ 改变位置就相当于交换 $c_j$ 与 $c_{j + 1}$ 。 然后就非常巧妙的实现了跳来跳去的一次操作。 然后我们考虑先把每个能交换的位置都交换一次，即跳一次，相当于初始化。 之后再倍增的跳，跳完之后可以很方便的把 $a_i$ 加回去，就是每一位的答案。 为什么可以这么做呢 $?$ 首先，倍增的正确性是显然的。 然后，由于我们先使用了经典套路差分来使插入操作转变成了交换操作。 所以，就巧妙地实现了题目的要求。 $Code:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl)#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); i--)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 100011;const ll inf = 0x3f3f3f3f3f3f;ll n, m, k, x, a[N], b[N], c[N], B[N];double res = 0;namespace IO &#123; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ( '-' ), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;inline void Redouble ( ll x ) &#123; for (; x; x &gt;&gt;= 1) &#123; if (x &amp; 1) &#123; For ( i, 1, n ) B[i] = a[b[i]]; For ( i, 1, n ) a[i] = B[i]; &#125; For ( i, 1, n ) B[i] = b[b[i]]; For ( i, 1, n ) b[i] = B[i]; &#125;&#125;int main() &#123; n = read(); For ( i, 1, n ) a[i] = read(), b[i] = i; foR ( i, n, 1 ) a[i] = a[i] - a[i - 1]; m = read(), k = read(); For ( i, 1, m ) x = read(), swap ( b[x], b[x + 1] ); Redouble (k); For ( i, 1, n ) res += a[i], printf ("%.1lf\n", res); return 0;&#125;/**/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
        <tag>expectation</tag>
        <tag>Redouble</tag>
        <tag>经典套路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随机树]]></title>
    <url>%2F2019%2F04%2F03%2F%E9%9A%8F%E6%9C%BA%E6%A0%91%2F</url>
    <content type="text"><![CDATA[$Random$ $Tree$$Description$一个有 $n$ 个节点的树可通过等概率选定节点展开的方式生成，现在有问题 $1$ 与 $2$ ，对于问题 $1$ ，求叶节点平均深度的数学期望值，对于问题二，求树深度的数学期望值，约定根节点深度为 $0$ 。 $Solution$先考虑第一问，求叶节点平均深度的期望值，这一问我们可以设 $f[i]$ 表示一棵有 i 个叶子节点的树的平均深度，总共就有 $f[i] \times i$ 的平均深度和。 显然，此处的贡献就是在当前 $i - 1$ 个节点中选择一个，使深度增加 $2$ ，节点数增加 $1$ ，所以转移方程就是$$f[i] \times i = f[i - 1] \times (i - 1) + (f[i - 1] + 1) \times 2 - f[i - 1]$$即$$f[i] = f[i - 1] + \frac{2}{i}$$然后我们考虑第二问。 我们设 $f[i][j]$ 为一棵有 $i$ 个叶子节点的树深度 $&gt;=j$ 的概率。 显然答案就是$$E(X) = \sum_{i = 1}^{n - 1}f[n][i]$$然后考虑怎么转移。 我们用 $f[i][j]$ 表示转移到的树的状态， $f[k][j - 1]$ 表示左子树的状态， $f[i - k][j - 1]$ 表示右子树的状态。 就有$$f[i][j] = \frac{f[k][j - 1] + f[i - k][j - 1] - f[k][j - 1] \times f[i - k][j - 1]}{i - 1}$$转移式其实就是代表我们用左子树与右子树拼出了一颗新树，显然形成这棵树的概率是一个容斥的式子，就是左子树深度 $&gt;= j - 1$ 的概率加上右子树深度 $&gt;= j - 1$ 的概率再减去左右子树深度均 $&gt;= j - 1$ 的概率，就是形成这棵新树的概率。 然后我们考虑为什么要除以 $i - 1​$ 。 让我们回到上一个状态，当时有 $i - 1$ 个叶子节点个数，我们从中选取一个节点拓展，获得了当前的 $f[i][j]$ ，所以构造出当前的 $f[i][j]$ 有 $\dfrac{1}{i - 1}​$ 的概率。 就做完了。 $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl)#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); i--)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 1011;const ll inf = 0x3f3f3f3f3f3f;ll q, n;namespace IO &#123; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ( '-' ), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;namespace Subtask1 &#123; double f[N]; inline void main () &#123; For ( i, 2, n ) f[i] = f[i - 1] + 2.0 / i; printf ("%.6lf", f[n]); exit (0); &#125; &#125;namespace Subtask2 &#123; double ans = 0.0, f[N][N], g[N][N]; inline void main () &#123; For ( i, 1, n ) f[i][0] = 1; For ( i, 1, n ) For ( j, 1, i - 1 ) &#123; For ( k, 1, i - 1 ) f[i][j] = f[i][j] + (f[k][j - 1] + f[i - k][j - 1] - f[k][j - 1] * f[i - k][j - 1]); f[i][j] /= (i - 1); &#125; For ( i, 1, n - 1 ) ans += f[n][i]; printf ("%.6lf", ans); exit (0); &#125; &#125;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); q = read(), n = read(); if ( q == 1 ) Subtask1::main (); if ( q == 2 ) Subtask2::main (); return 0;&#125;/*1 42.1666672 42.6666671 124.2064212 125.916614*/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
        <tag>expectation</tag>
        <tag>probability</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[屠龙勇士]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB%2F</url>
    <content type="text"><![CDATA[$Dragon$$Description$ $Ps:$一道好题。 重点在于对同余方程的推导，然后就很裸了。 对 $multiset$ 的应用也很漂亮。 $Solution$首先，我们根据题目所给条件，可以得出一个方程：$$x_i \times Atk_i \equiv a_i \pmod {p_i}$$也即$$x_i \equiv a_i \times Atk_{i}^{-1} \pmod {p_i}$$然后考虑如何求出 $Atk_{i}^{-1}$ ，并将其变成扩展 $Crt$ 的形式。 由于 $Atk_i$ 与 $p_i$ 不互素，所以无法直接求出他的逆元，所以我们考虑先求出 $gcd(a_i, p_i, Atk_i)$ ，然后把三个同除以 $gcd$ 。注意如果此时如果两数仍不互素，就无解。 然后 $exgcd$ 求下逆元，就变成拓展 $Crt$ 板子了。 $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define It multiset&lt;ll&gt;::iterator#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl)#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); i--)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 100011;const ll inf = 0x3f3f3f3f3f3f;multiset &lt; ll &gt; Atk;ll T, n, m, mx = 0, a[N], p[N], Blade[N], GetAtk[N];namespace IO &#123; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ( '-' ), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;ll mul ( ll a, ll b, ll p ) &#123; ll L = a * (b &gt;&gt; 25ll) % p * (1ll &lt;&lt; 25) % p; ll R = a * (b &amp; ((1ll &lt;&lt; 25) - 1)) % p; return (L + R) % p;&#125;//inline ll mul ( ll a, ll b, ll p ) &#123;// a %= p, b %= p;// return ( (a * b - (ll)((long double)(a * b - 0.5) / p) * p) % p + p ) % p;//// ll res = 0;//// for (; b; b &gt;&gt;= 1, a = (a + a) % p) res = (b &amp; 1)? Add (res, a, p): res;//// return res;//&#125;inline ll gcd ( ll a, ll b ) &#123; return !b? a: gcd (b, a % b); &#125;inline void exgcd ( ll a, ll b, ll &amp;d, ll &amp;x, ll &amp;y ) &#123; if (b) exgcd ( b, a % b, d, y, x ), y -= a / b * x; else d = a, x = 1, y = 0; return ;&#125;inline ll Inv ( ll a, ll b ) &#123; ll d, x, y; exgcd (a, b, d, x, y); return x + b &gt; b? x: x + b;&#125;inline ll exCrt( ll A[], ll B[], ll M[], ll &amp;res ) &#123; res = 0; ll lcm = 1; For ( i, 1, n ) &#123; ll a = mul (A[i], lcm, M[i]), b = B[i] - mul (A[i], res, M[i]), d = gcd (a, M[i]); if (b % d) return res = -1, 0; ll x = mul (b / d, Inv (a / d, M[i] / d), M[i] / d); res += lcm * x, lcm *= M[i] / d; &#125; return res = (res % lcm + lcm) % lcm, lcm;&#125;int main() &#123; freopen("dragon.in", "r", stdin); freopen("dragon.out", "w", stdout); T = read(); while ( T-- ) &#123; Atk.clear(); mx = 0; n = read(), m = read(); For ( i, 1, n ) a[i] = read(); For ( i, 1, n ) p[i] = read(); For ( i, 1, n ) GetAtk[i] = read(); For ( i, 1, m ) Atk.insert(read()); For ( i, 1, n ) &#123; It it = Atk.upper_bound(a[i]); // 找第一把大于初始生命值的。 if ( it != Atk.begin() ) --it; /* 如果不是攻击力最低的一把，就减一，选不高于巨龙生命值的 武器中攻击最高的。 */ Blade[i] = (*it); // 当前所用的剑。 Atk.erase(it), Atk.insert(GetAtk[i]); // 换上杀死后的剑。 mx = max ( mx, (a[i] + Blade[i] - 1) / Blade[i] ); // 即最少砍几刀杀死一头龙中最多需要砍的次数。 &#125; ll x, lcm = exCrt (Blade, a, p, x); if ( x != -1 &amp;&amp; x &lt; mx ) x += lcm * ( (mx - x + lcm - 1) / lcm ); // 向上取整。 wln (x); &#125; return 0;&#125;/*23 33 5 74 6 107 3 91 9 10003 23 5 64 8 71 1 11 159-1*/ [题目链接](]]></content>
      <tags>
        <tag>math</tag>
        <tag>exgcd</tag>
        <tag>Crt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[exCrt]]></title>
    <url>%2F2019%2F04%2F02%2FexCrt%2F</url>
    <content type="text"><![CDATA[$exCrt$前言十几天前写的板子…然而当时就不会证以及打，只是抄了个板子，今天准备把坑填上。 $Description$给定 $n$ 组非负整数 $a_i, b_i$ ，求解关于 $x$ 的方程组$$\begin{cases}x \equiv b_1\ ({\rm mod}\ a_1)\\x \equiv b_2\ ({\rm mod}\ a_2)\\\ldots\\x\equiv b_n ({\rm mod}\ a_n)\end{cases}$$ 的最小非负整数解。 $Solution$先从简单的入手，现在有$$\begin{cases}x \equiv b_1\ ({\rm mod}\ a_1)\\x \equiv b_2\ ({\rm mod}\ a_2)\end{cases}$$将其转换成$$\begin{cases}x = b_1k_1\\x = b_2k_2\end{cases}$$联立一下，就有$$b1k1 = a_2 - a_1 + b_2k_2$$根据 $exgcd$ 可知，满足有解的条件是 $gcd (b_1, b_2) | (a_2 - a_1)$ 设$$d = gcd(b_1, b_2)$$两边同除以 $d$ ，得$$\frac{b_1}{d}k_1 = \frac{a_2 - a_1}{d} + \frac{b_2}{d}k_2$$两边同时对 $\dfrac{b_2}{d}$ 取模，得$$\frac{b_1}{d}k_1 = \frac{a_2 - a_1}{d} \pmod { \frac{b_2}{d} }$$即$$k_1 \equiv (\frac{b_1}{d})^{-1} \times \frac{a_2 - a_1}{d} \pmod {\frac{b_2}{d}}$$也即$$k_1 = (\frac{b_1}{d})^{-1} \times \frac{a_2 - a_1}{d} + y\frac{b_2}{d}$$带回原式，得$$x = b_1 \times (\frac{b_1}{d})^{-1} \times \frac{a_2 - a_1}{d} + y\frac{b_1b_2}{d} + a_1$$即$$x = b_1 \times (\frac{b_1}{d})^{-1} \times \frac{a_2 - a_1}{d} + y\frac{b_1b_2}{d}$$设 $c = b_1 \times (\dfrac{b_1}{d})^{-1} \times \dfrac{a_2 - a_1}{d}, m = \dfrac{b_1b_2}{d}$ 就做出了这个简单的式子。 然后我们考虑通解。 设已经求出前 $k - 1$ 个方程组成的同余方程组得解为 $Ans$ ， $M = \operatorname{LCM}_{i - 1}^{k - 1}a[i]$ 。 所以前 $k - 1$ 个方程的通解为 $Ans + i * M$ 。 然后我们考虑加入第 $k$ 个方程后的方程组，也就是要我们求$$Ans + Mx \equiv b_k \pmod {a_k}$$也就是求$$Mx \equiv b_k - Ans \pmod {a_k}$$即$$Mx + a_ky = b_k - Ans$$然后我们考虑用 $exgcd$ 求出 $t$ ，重复 $n$ 遍即可。 $Code:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl)#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); i--)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 100011;const ll inf = 0x3f3f3f3f3f3f;ll n, B[N], A[N];namespace IO &#123; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ( '-' ), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;inline ll mul ( ll a, ll b, ll p ) &#123; ll res = 0; for (; b; b &gt;&gt;= 1, a = (a + a) % p) res = (b &amp; 1)? (res + a) % p: res; return res;&#125;inline void exgcd ( ll a, ll b, ll &amp;d, ll &amp;x, ll &amp;y ) &#123; if (b) exgcd ( b, a % b, d, y, x ), y -= a / b * x; else x = 1, y = 0, d = a; return ;&#125;inline ll exCrt() &#123; ll x, y, M = 1, ans = 0; For ( i, 1, n ) &#123; ll b = ((B[i] - ans) % A[i] + A[i]) % A[i]; ll d; exgcd ( M, A[i], d, x, y ); if (b % d) return -1; x = mul ( x, b / d, A[i] ); ans += x * M; M *= A[i] / d, ans = (ans + M) % M; &#125; return (ans % M + M) % M;&#125;int main() &#123;// freopen("testdata (6).in", "r", stdin);// freopen(".out", "w", stdout); n = read(); For ( i, 1, n ) A[i] = read(), B[i] = read(); return wln ( exCrt() ), 0;&#125;/**/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
        <tag>exgcd</tag>
        <tag>Crt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列统计]]></title>
    <url>%2F2019%2F04%2F01%2F%E5%BA%8F%E5%88%97%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[$Sequence$ $Statistics$$Description$给定三个整数 $N,L$ 和 $R$，统计长度在 $1$ 到 $N$ 之间，元素大小都在 $L$ 到 $R$ 之间的单调不降序列的数量，对 $10^6 + 3$ 取模。 $Solution$观察本题，我们会发现如果他是单调上升序列，那么会非常好做，直接 $\sum_{i = 1}^{n} C_{r - l + 1}^{i}$ 就完事了，但这题是单调不降序列，所以，此处有一个经典套路做法，把所有数字加上他自己的下标，转换成求单调不降序列来做。 如此，数的取值范围就是 $[l + 1, r + n]$ 。 然后答案就是有 $r - l + 1$ 个数可选，总共有 $r - l + n$ 个数。 也就是$$Ans = \sum_{i = 1}^{n} C_{r - l + i}^{r - l}$$显然这个东西复杂度是 $O(n)$ 的，所以我们考虑找规律优化。 我们把 $\sum$ 展开$$Ans = C_{r - l + 1}^{r - l} + C_{r - l + 2}^{r - l} \ldots + C_{r - l + n}^{r - l}$$然后我们考虑在前面加一项 $C_{r - l}^{r - l}$ ，就可以用组合数递推通项公式合并了。 最后的答案就是$$C_{r - l + 1 + n}^{r - l} - C_{r - l}^{r - l}$$即$$Ans = C_{r - l + 1 + n}^{r - l} - 1$$就做完了。 $Code:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl)#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); i--)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 1000011;const ll p = 1e6 + 3;const ll inf = 0x3f3f3f3f3f3f;ll T, n, l, r, fac[N + 5];namespace IO &#123; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ( '-' ), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;inline void Init() &#123; fac[0] = 1; For ( i, 1, N ) fac[i] = fac[i - 1] * i % p;&#125;inline ll power ( ll a, ll b ) &#123; ll res = 1; for (; b; b &gt;&gt;= 1, a = a * a % p) res = (b &amp; 1)? res * a % p: res; return res;&#125;inline ll Inv ( ll a, ll p ) &#123; return power ( a, p - 2 ); &#125;inline ll C ( ll n, ll m ) &#123; return n &lt; m? 0: fac[n] * Inv (fac[m], p) % p * Inv (fac[n - m], p) % p;&#125;inline ll Lucas ( ll n, ll m ) &#123; return !m? 1: C (n % p, m % p) * Lucas (n / p, m / p) % p;&#125;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); Init(); T = read(); while ( T-- ) &#123; n = read(), l = read(), r = read();// debug ( (r - l + 1 + n) / p ); wln ( (Lucas ( r - l + 1 + n, r - l + 1 ) - 1 + p) % p ); &#125; return 0;&#125;/*1728257683 297206817 9441266181000002*/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
        <tag>经典套路</tag>
        <tag>Lucas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数三角形]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%95%B0%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[$Counting$ $Delta$$Description$给定一个 $n \times m$ 的网格，请计算三点都在格点上的三角形共有多少个。 $Solution$考虑分类讨论。 首先，我们发现，每个顶点都在格点上的三角形能且只能被一个矩形完全包含，也就是 而下面这个当中的大矩形就是不包含这个下图中的三角形的，只有用红色标出的小矩形才包含。 所以就将问题转化成了求子矩形个数。 显然，长为 $i$ ，宽为 $j$ 的子矩形有 $(m - i + 1) \times (n - j + 1)$ 个。 然后考虑一个子矩形中有多少种可能的三角形个数。 我们考虑固定一个端点，移动其他两个端点： 红色的点表示固定的点，也就是 $A$ 点，绿色的线表示 $B$ 点此时的活动范围，橙色的线表示 $C$ 点此时的活动范围。 显然， $A​$ 点有 $4​$ 种方案， $B​$ 点有 $i - 1​$ 种方案， $C​$ 点有 $j - 1​$ 种方案。 所以方案数就是 $4 \times (i - 1) \times (j - 1)​$ 然后我们考虑处在顶点上的特殊情况，我们钦定 $B$ 与顶点重合。 当 $B$ 与左上角端点重合时， $C$ 就只能在右边的一条边上动，就有 $i - 1$ 种情况。 当 $B$ 与右下角端点重合时， $C$ 就只能在上面的一条边上动，就有 $j - 1$ 种情况。 当 $B​$ 与右上角端点重合时，情况就变得复杂了。 可以发现此时 $A \to B$ 不仅仅经过了左下角与右上角两个端点，还经过了中间的一些格点，手玩一下几个数据可以发现，经过的格点数是 $gcd(i, j) - 1$ 个。 所以，方案个数就是 $(i + 1) \times (j + 1) - 4 - (gcd(i, j) - 1)​$ 。 注意此处图形可以翻转，所以答案要乘二。 所以，对于每个子矩阵，完全覆盖的三角形个数就是$$4 \times (i - 1) \times (j - 1) + 2 \times [(i - 1) + (j - 1) + (i + 1) \times (j + 1) - 4 - (gcd(i, j) - 1)]$$化简后就是$$6 \times i \times j - 2 \times gcd(i, j)$$ $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl)#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); i--)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 100011;const ll inf = 0x3f3f3f3f3f3f;ll m, n, ans = 0; namespace IO &#123; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ( '-' ), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;inline ll gcd ( ll a, ll b ) &#123; return !b? a: gcd (b, a % b); &#125;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); m = read(), n = read(); For ( i, 1, m ) For ( j, 1, n ) ans += ( m - i + 1 ) * ( n - j + 1 ) * ( 6 * i * j - 2 * gcd (i, j) ); return wln (ans), 0;&#125;/*2 276*/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
        <tag>category talk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[exLucas]]></title>
    <url>%2F2019%2F03%2F29%2FexLucas%2F</url>
    <content type="text"><![CDATA[$exLucas$$Description$求$$C_n^m \bmod p$$不保证 $p$ 为质数， $1&lt;=n, m &lt;= 10^{18}$ 。 $Solution$考虑先将 $p$ 质因数分解。$$p = \prod_{i}p_i^{a_i}$$显然 $p_i^{a_i}$ 两两互质，所以只需要分别求出 $C_{n}^{m} \bmod p^k$ ，构造出多个形如 $C_{n}^{m} = b_i \bmod p_i^{a_i} $ 的方程，最后用 $Crt$ 合并求解即可。 然后考虑求$$C_{n}^{m} \bmod p^k$$根据组合数公式$$C_{n}^{m} = \dfrac{n!}{m!(n-m)!}$$由于 $m!$ 与 $(n - m)!$ 中可能含有因子 $p$ ，不能直接求对于 $p^k$ 的逆元，所以考虑先提出 $n!, m!, (n - m)!$ 中的 $p$ ，最后乘回去即可。 也就是$$\dfrac{\dfrac{n!}{p^{k_1}}}{\dfrac{m!}{p^{k_2}} \times \dfrac{(n - m)!}{p^{k_3}}} \times p^{k_1 - k_2 - k_3}$$显然 $\dfrac{m!}{p^{k_2}}, \dfrac{(n - m)!}{p^{k_3}}$ 与 $p^k$ 互质，直接求逆元即可。 之后考虑如何求形如 $\dfrac{n!}{p^{a}} \bmod p^k$ 的式子。 先举个栗子，如果$$n = 23, p = 3, k = 2$$有$$23! = 1 \times 2 \times 3 \ldots \times 23$$提出 $p$ 的所有倍数$$3^{7} \times 7! \times (1 \times 2 \times 4 \times 5 \times 7 \times 8 \ldots)$$可以看出第一部分是 $p^{\left\lfloor\frac{n}{p}\right\rfloor}​$ ，第二部分是 $\left\lfloor\frac{n}{p}\right\rfloor!​$ ，第三部分是 $\prod_{gcd(d, p) = 1}^{n!}d​$ 。 显然第一部分对于答案没有贡献，第二部分递归即可，所以现在还需要解决第三部分。 观察原式可发现$$1 \times 2 \times 4 \times 5 \times 7 \times 8 \equiv 10 \times 11 \times 13 \times 14 \times 16 \times 17 \pmod {p^k}$$显然，在 $\bmod {p^k}$ 意义下，第三部分的每一份乘积全部与 $\prod_{i = 1, gcd(i, p) = 1}^{p^k}$ 同余。 显然，这些部分有 $\frac{n}{p^k}$ 个，所以只需要暴力算出一次互质的，然后快速幂即可。 记住最后要加上不完整的块，也就是例子里的 $19 \times 20 \times 22 \times 23 $ 。 然后我们回到求组合数的过程，提出因子 $p$ ，最后乘上逆元与提出的 $p$ 即可。 对于原问题， $Crt$ 合并即可。 $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl)#define re register#define For(i, j, k) for(re ll i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re ll i = (j); i &gt;= (k); i--)#define Cross(i, j, k) for(re ll i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 100011;const ll inf = 0x3f3f3f3f3f3f;ll n, m, p;namespace IO &#123; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ( '-' ), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;namespace Solve &#123; inline void exgcd ( ll a, ll b, ll &amp;d, ll &amp;x, ll &amp;y ) &#123; if (b) exgcd ( b, a % b, d, y, x ), y -= a / b * x; else d = a, x = 1, y = 0; return ; &#125; inline ll power ( ll a, ll b, ll p ) &#123; ll res = 1; for (; b; b &gt;&gt;= 1, a = a * a % p) res = (b &amp; 1)? res * a % p: res; return res; &#125; inline ll Inv ( ll a, ll p ) &#123; ll d, x, y; exgcd ( a, p, d, x, y ); return (x + p &gt; p)? x: x + p; &#125; // exgcd 求逆元。 inline ll Crt ( ll b, ll mod ) &#123; return b * Inv ( p / mod, mod ) % p * ( p / mod ) % p; &#125; // Crt 合并答案。 inline ll Devide ( ll n, ll p, ll k ) &#123; if (!n) return 1; ll res = 1; For ( i, 2, k ) if (i % p) res = res * i % k; // 计算一次第三部分 res = power ( res, n / k, k ); // 总共有 n / k 次第三部分。 For ( i, 2, n % k ) if (i % p) res = res * i % k; // 第三部分有一点没被乘进去。 return res * Devide ( n / p, p, k ) % k; // 乘上第二部分。 &#125; // 求阶乘。 inline ll C ( ll n, ll m, ll p, ll k ) &#123; if ( n &lt; m ) return 0; ll cnt = 0, a = Devide (n, p, k), b = Devide (m, p, k), c = Devide (n - m, p, k); Cross ( i, n, i / p ) cnt += i / p; Cross ( i, m, i / p ) cnt -= i / p; Cross ( i, n - m, i / p ) cnt -= i / p; return a * Inv (b, k) % k * Inv (c, k) % k * power (p, cnt, k) % k; &#125; // 求组合数。 n! / m!(n - m)! inline ll exLucas () &#123; ll res = 0, temp = p; for (re int i = 2; i * i &lt;= temp; i++) if (temp % i == 0) &#123; ll t = 1; while (temp % i == 0) t *= i, temp /= i; res = (res + Crt ( C(n, m, i, t), t )) % p; &#125; return (temp &gt; 1)? (res + Crt ( C(n, m, temp, temp), temp )) % p: res; &#125; // 分解质因数， Crt 合并答案。 /* t 就是 p^k, i 就是 p 。 */ &#125;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); n = read(), m = read(), p = read(); return wln ( Solve::exLucas () ), 0;&#125;/*157705804463339796 195211 821261150052*/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
        <tag>exgcd</tag>
        <tag>Lucas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C Looooops]]></title>
    <url>%2F2019%2F03%2F26%2FC-Looooops%2F</url>
    <content type="text"><![CDATA[$C$ $Looooops$$Description$求$$Cx + A \equiv B \pmod {2^k}$$ $Solution$化简本式：$$Cx + 2^{k}y = B - A$$所以：$$a = C, b = 2^k, c = B - A, d = gcd(a, b)$$代入求解即可。 $Code:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl)#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); i--)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 100011;const ll inf = 0x3f3f3f3f3f3f;ll A, B, C, k;namespace IO &#123; inline ll read() &#123; ll x = 0; bool f = 0; char ch = getchar(); for (; !isdigit (ch); ch = getchar()) f ^= (ch == '-'); for (; isdigit (ch); ch = getchar()) x = ( x &lt;&lt; 3 ) + ( x &lt;&lt; 1 ) + ( ch ^ 48 ); return f? -x: x; &#125; inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ( '-' ), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;inline void exgcd ( ll a, ll b, ll &amp;d, ll &amp;x, ll &amp;y ) &#123; if (b) exgcd ( b, a % b, d, y, x ), y -= a / b * x; else d = a, x = 1, y = 0; return ;&#125;int main() &#123;// freopen("c.in", "r", stdin);// freopen("test.out", "w", stdout); while ( cin &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; k &amp;&amp; (A || B || C || k) ) &#123; ll a = C, b = 1ll &lt;&lt; k, c = B - A; ll d, x, y; exgcd ( a, b, d, x, y ); if (c % d) &#123; puts("FOREVER"); continue; &#125; x = x * (c / d); b /= d; x = (x % b + b) % b; wln (x); &#125; return 0;&#125;/*3 3 2 163 7 2 167 3 2 163 4 2 160 0 0 0*/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
        <tag>exgcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Park]]></title>
    <url>%2F2019%2F03%2F26%2FPark%2F</url>
    <content type="text"><![CDATA[$Park$$Description$123456789游乐园里新推出一个游戏——飞机驾驶体验。有*N*-1 个小朋友来玩这个游戏，他们排成长长的一列。这个游戏一共有 M 架“飞机”可供驾驶，每架飞机的使用时间都是有限制的，第 i 架“飞机”的使用时间是 si 分钟。 一开始所有“飞机”都是闲置着的，然后排队等候着的小朋友依次上“飞机”。如果有飞机闲置，则小朋友一定会上去玩(小朋友不会在意飞机使用的时间)；如果同时有多架“飞机”闲置着，小朋友一定会选择标号最小的那架。 现在你带着你的弟弟来到了游乐园，排到了最后一个位置。你想知道你弟弟会在哪架“飞机”上体验。 $Solution$考虑二分弟弟上飞机的时间。 $check$ 函数很好写，只需要将所有的 $s_i$ 在这么长时间内上去几个人算出来就好了。 二分出时间后，取时间减一， $n$ 与时间减一的差就是弟弟在这分钟上去飞机次序。 把所有在这一分钟满足条件的飞机取出，第 $n - res$ 即为答案。 $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl)#define re register#define For(i, j, k) for(re int i = j; i &lt;= k; i++)#define foR(i, j, k) for(re int i = j; i &gt;= k; i--)#define Cros(i, j, k) for(re int i = j; i; i = k)using namespace std;typedef long long ll;const ll N = 100011;const ll inf = 0x3f3f3f3f3f3f3f;/* 二分真**难调。 */ll n, m, s[N];ll t = 1, zz = 0, bei[N];namespace IO &#123; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write ( ll x ) &#123; if ( x &lt; 0 ) x = -x, putchar ('-'); if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar (' '); &#125; inline void wln ( ll x ) &#123; write (x); putchar ('\n'); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x); wln (y); &#125; &#125;using namespace IO;namespace Subtask1 &#123; ll mn = inf; inline void main () &#123; For ( i, 1, m ) s[i] = read(), mn = min ( mn, s[i] ); zz = m; if ( n - 1 &lt;= m ) &#123; wln (n - 1); exit (0); &#125; while (1) &#123; t ++; For ( i, 1, m ) &#123; // debug (t % s[i]); if ( t % s[i] == 0 ) zz++; if ( zz == n ) &#123; wln (i); exit (0); &#125; &#125; &#125; &#125; &#125;namespace Subtask &#123; ll mx = 0, cnt = 0, alb[N]; inline bool check ( ll ss ) &#123; ll res = 0; For ( i, 1, m ) res += ss / s[i] + 1; return res &gt;= n; &#125; inline void main () &#123; For ( i, 1, m ) s[i] = read(), mx = max ( mx, s[i] ); ll l = 1, r = mx * n; while ( l &lt;= r ) &#123; ll Mid = ( l + r ) &gt;&gt; 1; check (Mid)? r = Mid - 1: l = Mid + 1; &#125; // 二分在第几分钟上飞机。// wln (l); ll aa = l, res = 0, ress = 0, albb; For ( i, 1, m ) res += aa / s[i] + 1; For ( i, 1, m ) ress += (aa - 1) / s[i] + 1; albb = n - ress;// debug (ress);// ress -= res; For ( i, 1, m ) if ( aa % s[i] == 0 ) alb[++cnt] = i;// For ( i, 0, cnt - 1 ) wln ( alb[i] ); wln ( alb [albb] ); &#125; &#125;int main () &#123; freopen("park.in", "r", stdin); freopen("park.out", "w", stdout); n = read(), m = read(); // ( n &lt;= 1000000 )? // Subtask1::main (); Subtask::main (); return 0; // Sherry, &#125;/*22 51 2 3 4 5431 51 2 3 4 5332 51 2 3 4 5433 51 2 3 4 51*/]]></content>
      <tags>
        <tag>two points answer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超能粒子炮·改]]></title>
    <url>%2F2019%2F03%2F22%2F%E8%B6%85%E8%83%BD%E7%B2%92%E5%AD%90%E7%82%AE%C2%B7%E6%94%B9%2F</url>
    <content type="text"><![CDATA[$Super$ $Particle$ $Cannon$$Description$求$$\sum_{i = 0}^{k} C_n^i \bmod 2333$$ $Solution$设$$f(n, k) = \sum_{i = 0}^{k} C_n^i$$即$$\sum_{i = 0}^{k}C_{n / p}^{i / p} \times C_{n \% p}^{i \% p}$$数论分块一下，此处将其分成 $k / p$ 个块，许多数字同属一个块，就一起算掉。$$\sum_{i = 0}^{p - 1}C_{n \% p}^{i}C_{n / p}^{0} + \sum_{i = 0}^{p - 1}C_{n \% p}^{i}C_{n / p}^{1} + … + \sum_{i = 0}^{p - 1}C_{n \% p}^{i}C_{n / p}^{k / p - 1} + \sum_{i = 0}^{k \% p}C_{n \% p}^{i}C_{n / p}^{k / p}$$把 $\sum_{i = 0}^{p - 1}C_{n \% p}^{i}$ 提出来$$\sum_{i = 0}^{p - 1}C_{n \% p}^{i} \sum_{i = 0}^{k}C_{n / p}^{i / p - 1}$$也就是$$f(n \% p, p - 1) \times f(n / p, k / p - 1)$$最后一个不完整的块单独处理$$\sum_{i = 0}^{k \% p}C_{n \% p}^{i}$$即$$f(n \% p,k \% p)$$所以$$f(n, k) = f(n \% p, p - 1) \times f(n / p, k / p - 1) + C_{n / p}^{k / p} \times f(n \% p, k \% p)$$预处理组合数，套个 $Lucas$ 就完了。 $Code:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); i--)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll p = 2333;const ll N = 2345;const ll inf = 0x3f3f3f3f3f3f;ll T, n, k, res, C[N + 11][N + 11], f[N + 11][N + 11];namespace IO &#123; inline ll read() &#123; ll x = 0; bool f = 0; char ch = getchar(); for (; !isdigit (ch); ch = getchar()) f ^= (ch == '-'); for (; isdigit (ch); ch = getchar()) x = ( x &lt;&lt; 3 ) + ( x &lt;&lt; 1 ) + ( ch ^ 48 ); return f? -x: x; &#125; inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ( '-' ), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;inline ll Lucas ( ll n, ll m ) &#123; if ( n &lt; m ) return 0; if ( !m || n == m ) return 1; return C[n % p][m % p] * Lucas ( n / p, m / p ) % p;&#125;inline ll F ( ll n, ll k ) &#123; if ( k &lt; 0 ) return 0; if ( !n || !k ) return 1; if ( n &lt; p &amp;&amp; k &lt; p ) return f[n][k]; return ( F (n / p, k / p - 1) * f[n % p][p - 1] % p + Lucas ( n / p, k / p ) * f[n % p][k % p] % p ) % p;&#125;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); f[0][0] = C[0][0] = 1; For ( i, 1, N ) C[i][i] = C[i][0] = f[i][0] = 1; For ( i, 1, N ) For ( j, 1, i - 1 ) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % p; For ( i, 0, N ) For ( j, 1, N ) f[i][j] = ( C[i][j] + f[i][j - 1] ) % p; T = read(); while ( T-- ) n = read(), wln ( F (n, read()) ); return 0;&#125;/*35 510 71145 1432968763*/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
        <tag>Lucas</tag>
        <tag>数论分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Savage]]></title>
    <url>%2F2019%2F03%2F22%2FSavage%2F</url>
    <content type="text"><![CDATA[$Savage$$Description$给出 $n$ 个野人，初始在第 $C_i$ 个洞穴，每个人一年能走 $P_i$ 个洞穴，寿命是 $L_i$ 年，所有人在一个环上走，求最小满足所有人互不碰到的环的长度。 $Solution$由题意得，我们需要使 $C_{i} + P_i \times x \equiv C_j + P_j \times x \bmod M$ $(x &lt;=1, min(L_i, L_j))$ $|$ $x &gt; min(L_i, L_j)$ 无解。 考虑化简式子：$$(P_i - P_j) \times x \equiv C_j - C_i \pmod M$$移项，变成 $exgcd$ 方程组：$$(P_i - P_j) \times x + M \times y = C_j - C_i$$枚举 $M$ ，解方程即可。 $Code:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); i--)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 111;const ll inf = 0x3f3f3f3f3f3f;ll n, mx, C[N], P[N], L[N];namespace IO &#123; inline ll read() &#123; ll x = 0; bool f = 0; char ch = getchar(); for (; !isdigit (ch); ch = getchar()) f ^= (ch == '-'); for (; isdigit (ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); return f? -x: x; &#125; inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ('-'), x = -x; if ( x &gt; 9 ) write (x / 10); putchar (x % 10 | 48); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;inline ll gcd ( ll a, ll b ) &#123; return !b? a: gcd (b, a % b); &#125;inline void exgcd ( ll a, ll b, ll &amp;d, ll &amp;x, ll &amp;y ) &#123; if (b) &#123; exgcd (b, a % b, d, y, x); y -= a / b * x; &#125; else d = a, x = 1, y = 0; return ;&#125;inline bool check ( ll M ) &#123; For ( i, 1, n ) For ( j, i + 1, n ) &#123; ll d, a = P[i] - P[j], b = M, v = C[j] - C[i], x = 0, y = 0, GCD = gcd ( a, b ); if ( v % GCD == 0 ) &#123; a /= GCD, b /= GCD, v /= GCD; exgcd ( a, b, d, x, y ); b = b &lt; 0? -b: b; x = (x * v % b + b) % b; x = !x? x + b: x; if ( x &lt;= min ( L[i], L[j] ) ) return false; &#125; &#125; return 1;&#125;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); n = read(); For ( i, 1, n ) mx = max (mx, C[i] = read()), P[i] = read(), L[i] = read(); for (re int i = mx; ; i++) if ( check (i) ) return wln (i), 0; return 0;&#125;/*31 3 42 7 33 2 16*/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
        <tag>exgcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Multiplicative inverse]]></title>
    <url>%2F2019%2F03%2F22%2FMultiplicative-inverse%2F</url>
    <content type="text"><![CDATA[$linear$ $inverse$ $element$$Descirption$给出 $k$ ，求它的逆元。 $Solution$设$$a \times k + b = p,{b \times inv[b]}\equiv1\pmod p$$变式，得$$b = p - a \times k,{(p - a \times k) \times inv[b]}\equiv1\pmod p$$ 拆括号，得$${p \times inv[b] - a \times k \times inv[b]}\equiv1\pmod p$$即$${-a \times k \times inv[b]}\equiv1\pmod p$$观察$$a \times k + b = p$$两边同是对 $k$ 取模，得$$b = p \bmod k$$故有$$a = p \div k$$代入原式，得$${-(p / k) \times inv[p \bmod k] \times k}\equiv 1 \pmod p$$即$${-(p / k) \times inv[p \bmod k]} \equiv inv[k] \pmod p$$ 也就是$${(p-p / k) \times inv[p \bmod k]} \equiv inv[k] \pmod p$$ $Code:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl#define re register#define For(i, j, k) for(re int i = j; i &lt;= k; i++)#define foR(i, j, k) for(re int i = j; i &gt;= k; i--)using namespace std;typedef long long ll;const ll N = 200011;const ll inf = 0x3f3f3f3f3f3f;ll n, p, f[N];namespace IO &#123; inline ll read() &#123; ll x = 0; bool f = 0; char ch = getchar(); for(; !isdigit( ch ); ch = getchar()) f^=( ch == '-' ); for(; isdigit( ch ); ch = getchar()) x = ( x &lt;&lt; 3 ) + ( x &lt;&lt; 1 ) + ( ch ^ 48 ); return f? -x: x; &#125; inline void write( ll x ) &#123; if( x &lt; 0 ) putchar( '-' ), x = -x; if( x &gt; 9 ) write( x / 10 ); putchar( x % 10 | 48 ); &#125; inline void wln( ll x ) &#123; write( x ); putchar( '\n' ); &#125;&#125;using namespace IO;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); n = read(), p = read(); f[1] = 1; For ( i, 2, n ) f[i] = ( p - p / i ) * f[p % i] % p; For ( i, 1, n ) wln ( f[i] ); return 0;&#125;/**/]]></content>
      <tags>
        <tag>math</tag>
        <tag>Study Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聪明的燕姿]]></title>
    <url>%2F2019%2F03%2F21%2F%E8%81%AA%E6%98%8E%E7%9A%84%E7%87%95%E5%A7%BF%2F</url>
    <content type="text"><![CDATA[$Smart$ $Yanzi$$Description$给你一个数 $S$ ，求有多少数的约数和等于 $S$ 。 $Solution$对于一个数 $S$ ，根据算数基本定理，有分解式：$$S = p_1^{a_1}p_2^{a_2}p_3^{a_3}…p_n^{a_n}$$所以约数和就是$$sum = \prod_{i = 1}^{n}\sum_{j=0}^{a_i}p_i^j$$由于 $S&lt;=2*10^9$ ，考虑枚举 $S$ 的所有因子，先筛出 $\sqrt{S}$ 以内的质数，然后枚举 $p_i$ ，对于每个 $p_i$ 枚举 $a_i$ ，爆搜，如果将 $S$ 分解成功，答案 $ + 1$ 。 同时，如果 $S - 1$ 是一个质数，且 $&gt;=$ 当前搜的 $p_i$ ，答案也要 $ + 1$ ，因为 $S - 1$ 也是此时构造出的数的因子。 其实我们是先把质因子全部取出来，然后找所有的乘起来的可能，对于每种可能都枚举它是否成立。 就是把 $S$ 拆掉，然后再拼回去。 $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); i--)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 100011;const ll inf = 0x3f3f3f3f3f3f;ll S, tot = 0, di[N &lt;&lt; 2];namespace IO &#123; inline ll read() &#123; ll x = 0; bool f = 0; char ch = getchar(); for (; !isdigit (ch); ch = getchar()) f^= (ch == '-'); for (; isdigit (ch); ch = getchar()) x = ( x &lt;&lt; 3 ) + ( x &lt;&lt; 1 ) + ( ch ^ 48 ); return f? -x: x; &#125; inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ( '-' ), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;ll cnt, pr[N], vis[N];inline void Init () &#123; For ( i, 2, N ) &#123; if ( !vis[i] ) pr[++cnt] = i; for ( re int j = 1; j &lt;= cnt &amp;&amp; i * pr[j] &lt;= N; j++ ) &#123; vis[i * pr[j]] = 1; if ( i % pr[j] == 0 ) break; &#125; &#125;&#125; // 预处理质数。 inline bool check ( ll n ) &#123; if ( n == 1 ) return 0; if ( n &lt;= N ) return !vis[n]; for ( re int i = 1; pr[i] * pr[i] &lt;= n; i++ ) if ( n % pr[i] == 0 ) return 0; return 1;&#125; // 判断质数。 inline void dfs ( ll now, ll x, ll y ) &#123; // x 表示当前用到第几个质数，y 表示当前搜出的数。 if ( now == 1 ) &#123; di[++tot] = y; return ; &#125; // 满足答案。 if ( now - 1 &gt;= pr[x] &amp;&amp; check ( now - 1 ) ) di[++tot] = y * ( now - 1 ); /* 如果当前数能表示成一个质数加一与一的乘积，那么就会是答案，只需要将 当前算出的答案乘上它就是满足条件的答案。 */ ll p, temp; for ( re int i = x; pr[i] * pr[i] &lt;= now; i++ ) &#123; temp = pr[i], p = pr[i] + 1; for (; p &lt;= now; temp *= pr[i], p += temp) if ( now % p == 0 ) dfs ( now / p, i + 1, y * temp ); &#125; // 枚举符合题意的因子。&#125;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); Init (); while ( cin &gt;&gt; S ) &#123; tot = 0; memset ( di, 0, sizeof ( di ) ); dfs ( S, 1ll, 1ll ); sort ( di + 1, di + tot + 1 ); // 从小到大输出。 wln (tot); For ( i, 1, tot - 1 ) wrn ( di[i] ); if (tot) wln ( di[tot] ); &#125; return 0;&#125;/*4220 26 41*/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sakura]]></title>
    <url>%2F2019%2F03%2F21%2FSakura%2F</url>
    <content type="text"><![CDATA[$Sakura$$Description$求 $\frac{1}{x} + \frac{1}{y} = \frac{1}{n!}$ 的答案方案个数。 $Solution$设$$x = n! - a, y = n! - b, n = n!$$代入，得$$\frac{2n - a - b}{(n - a)(n - b)} = \frac{1}{n}$$化简，移项，得$$2n^2 - (a + b)n = n^2 - (a + b)n + ab$$故有$$ab = n^2$$筛出 $n^2$ 的因子即可。 $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl#define re register#define For(i, j, k) for(re ll i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re ll i = (j); i &gt;= (k); i--)#define cross(i, k) for(re int i = head[k]; i; i = e[i].next)using namespace std;typedef long long ll;const ll N = 2000011;const ll p = 1e9 + 7;const ll inf = 0x3f3f3f3f3f3f;ll n;namespace IO &#123; inline ll read() &#123; ll x = 0; bool f = 0; char ch = getchar(); for (; !isdigit (ch); ch = getchar()) f^= (ch == '-'); for (; isdigit (ch); ch = getchar()) x = ( x &lt;&lt; 3 ) + ( x &lt;&lt; 1 ) + ( ch ^ 48 ); return f? -x: x; &#125; inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ( '-' ), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125;&#125;using namespace IO;ll ans = 1, cnt, c[N], pr[N], vis[N];inline void Init () &#123; For ( i, 2, n ) &#123; if ( !vis[i] ) vis[i] = pr[++cnt] = i; for ( re int j = 1; j &lt;= cnt &amp;&amp; i * pr[j] &lt;= n; j++ ) &#123; if ( pr[j] &gt; vis[i] ) break; vis[i * pr[j]] = pr[j]; &#125; &#125;&#125;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); n = read(); Init (); For ( i, 1, cnt ) &#123; ll P = pr[i]; for ( re ll j = P; j &lt;= n; j *= P ) c[i] += n / j; c[i] %= p; // 直接分解质因数。 &#125; For ( i, 1, cnt ) ans = ans * (c[i] * 2 + 1) % p; return wln ( ans ), 0;&#125;/*1439*/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Slingshot]]></title>
    <url>%2F2019%2F03%2F18%2FSlingshot%2F</url>
    <content type="text"><![CDATA[$Slingshot$对于本题，我们进行分类讨论： $ 1. $ 对于这种情况，$x \to y$ 包含了 $s \to t$ ，所以此时的选择有两种： ① 先从 $s$ 走到 $x$ ，然后穿到 $y$ ，再从 $y$ 走到 $t$ 。 ② 直接从 $s$ 走到 $t$ 。 然后我们 $yy$ 一下，如何用线段树维护多个 $x \to y$ 只选一个最优的 $x \to y$ 的情况。 显然，这是个线段树维护区间最小值裸题。 所以，由于我们根据 $x$ 端点排序，所以只需要将 ① 情况的路程插入线段树中的 $ y $ 节点的位置即可。 对于这种情况，路程就是$$ti + (s - x) + (y - t)$$在线段树中插入这个东东即可。 $ 2. $ 对于这种情况， $ s \to t $ 包含了 $ x \to y $ 的情况，所以路程就是$$ti + (x - s) + (t - y)$$$ 3. $ 对于这种情况， $ s \to t $ 包含了 $ x $ ，不包含 $ y $ ，所以路程就是$$ti + (s - x) + (t - y)$$$ 4. $ 与 $ 3 $ 同理，只是包含情况反一下，也就是$$ti + (x - s) + (y - t)$$离散化一下，四种情况各建一棵线段树就完了。 $ Code: $123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define debug(x) cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl#define ls(x) (x &lt;&lt; 1)#define rs(x) (x &lt;&lt; 1 | 1)#define mid ((l + r) &gt;&gt; 1)#define re register#define For(i, j, k) for(re int i = j; i &lt;= k; i++)#define foR(i, j, k) for(re int i = j; i &gt;= k; i--)using namespace std;typedef long long ll;const ll N = 200011;const ll inf = 0x3f3f3f3f3f3f3f;ll n, m, cnt, rep[N];struct node &#123; ll x, y, w, id;&#125; p[N];inline bool cmp ( node a, node b ) &#123; return a.x == b.x? a.x &lt; b.y: a.x &lt; b.x; &#125;namespace IO &#123; inline ll read() &#123; ll x = 0; bool f = 0; char ch = getchar(); for (; !isdigit (ch); ch = getchar()) f ^= ( ch == '-' ); for (; isdigit (ch); ch = getchar()) x = ( x &lt;&lt; 1 ) + ( x &lt;&lt; 3 ) + ( ch ^ 48 ); return f? -x: x; &#125; inline void write ( ll x ) &#123; if ( x &lt; 0 ) x = -x, putchar ( '-' ); if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125;&#125;using namespace IO;namespace Segment_Tree &#123; struct Tree &#123; ll mn; &#125; ans[N &lt;&lt; 2]; inline void push_up ( ll p ) &#123; ans[p].mn = min ( ans[ls(p)].mn, ans[rs(p)].mn ); &#125; inline void build ( ll p, ll l, ll r ) &#123; if ( l == r ) &#123; ans[p].mn = inf; return ; &#125; build ( ls(p), l, mid ); build ( rs(p), mid + 1, r ); push_up (p); &#125; inline void Insert ( ll p, ll l, ll r, ll x, ll k ) &#123; if ( l == r ) &#123; ans[p].mn = min ( k, ans[p].mn ); return ; &#125; if ( mid &gt;= x ) Insert ( ls(p), l, mid, x, k ); if ( mid &lt; x ) Insert ( rs(p), mid + 1, r, x, k ); push_up (p); &#125; inline ll Query ( ll p, ll l, ll r, ll ul, ll ur ) &#123; if ( l &gt;= ul &amp;&amp; r &lt;= ur ) return ans[p].mn; if ( mid &gt;= ur ) return Query ( ls(p), l, mid, ul, ur ); else if ( mid &lt; ul ) return Query ( rs(p), mid + 1, r, ul, ur ); else return min ( Query ( ls(p), l, mid, ul, ur ), Query ( rs(p), mid + 1, r, ul, ur ) ); &#125; &#125;using namespace Segment_Tree;ll u, v, w, s, t, _x[N], _y[N];int main () &#123; freopen ("ztn.in", "r", stdin); freopen ("ztn.out", "w", stdout); n = read(), m = read(); For ( i, 1, n ) &#123; u = read(), v = read(), w = read(); p[++cnt].x = u, p[cnt].y = v, p[cnt].w = w, p[cnt].id = 0; _x[cnt] = u, _y[cnt] =v; &#125; For ( i, 1, m ) &#123; s = read(), t = read(); p[++cnt].x = s, p[cnt].y = t, p[cnt].w = 0, p[cnt].id = i; _x[cnt] = s, _y[cnt] =t; rep[i] = abs ( s - t ); &#125; /* -----------------离散化----------------- */ sort ( p + 1, p + cnt + 1, cmp ); sort ( _x + 1, _x + cnt + 1 ); ll len = unique ( _x + 1, _x + cnt + 1 ) - _x - 1; For ( i, 1, cnt ) p[i].x = lower_bound ( _x + 1, _x + len + 1, p[i].x ) - _x; sort ( _y + 1, _y + cnt + 1 ); len = unique ( _y + 1, _y + cnt + 1 ) - _y - 1; For ( i, 1, cnt ) p[i].y = lower_bound ( _y + 1, _y + len + 1, p[i].y ) - _y; /* ---------------------------------- */ /* ----------------分类讨论------------------ */ build ( 1, 1, cnt ); For ( i, 1, cnt ) if ( !p[i].id ) Insert ( 1, 1, cnt, p[i].y, p[i].w -_x[p[i].x] - _y[p[i].y] ); else rep[p[i].id] = min ( rep[p[i].id], Query ( 1, 1, cnt, 1, p[i].y ) + _x[p[i].x] + _y[p[i].y] ); // x -&gt; y 包含 s ，不包含 t 。 build ( 1, 1, cnt ); For ( i, 1, cnt ) if ( !p[i].id ) Insert ( 1, 1, cnt, p[i].y, p[i].w -_x[p[i].x] + _y[p[i].y] ); else rep[p[i].id] = min ( rep[p[i].id], Query ( 1, 1, cnt, p[i].y, cnt ) + _x[p[i].x] - _y[p[i].y] ); // s -&gt; t 包含 x -&gt; y build ( 1, 1, cnt ); foR ( i, cnt, 1 ) if ( !p[i].id ) Insert ( 1, 1, cnt, p[i].y, p[i].w + _x[p[i].x] + _y[p[i].y] ); else rep[p[i].id] = min ( rep[p[i].id], Query ( 1, 1, cnt, p[i].y, cnt ) - _x[p[i].x] - _y[p[i].y] ); // x -&gt; y 包含 t ， 不包含 s 。 build ( 1, 1, cnt ); foR ( i, cnt, 1 ) if ( !p[i].id ) Insert ( 1, 1, cnt, p[i].y, p[i].w + _x[p[i].x] - _y[p[i].y] ); else rep[p[i].id] = min ( rep[p[i].id], Query ( 1, 1, cnt, 1, p[i].y ) - _x[p[i].x] + _y[p[i].y] ); // x -&gt; y 包含 s -&gt; t /* ---------------------------------- */ For ( i, 1, m ) wln ( rep[i] ); return 0;&#125;/*2 30 10 113 8 21 125 220 7*/ 另外，关于循环的问题为什么有两种正序，两种倒序呢？ 让我们再看一遍先前的例图： 前两个正序的： 后两个倒序的： 发现了吗，两者之间的奥秘。 留给读者自行证明。 从前面开始扫，由于 $ y $ 是排过序的，你插入的点就会在 $ s \to t $ 之间，否则有可能在外面，就是不优的，是错的。 题目链接]]></content>
      <tags>
        <tag>segment tree</tag>
        <tag>category talk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遥远的国度]]></title>
    <url>%2F2019%2F03%2F15%2F%E9%81%A5%E8%BF%9C%E7%9A%84%E5%9B%BD%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[$A$ $distant$ $country$### $Description$给出一棵树，需要支持换根、区间查询、区间修改等操作。 $Solution$除了换根操作，其他都是树链剖分板子。 对于换根操作，我们考虑先以一号节点为根节点做一次树剖，然后对于换根的操作分类讨论。 接下来以 $ root ​$ 表示目前的根节点， $ x ​$ 表示 $ x ​$ 子树。 $1.​$ $x == root​$ 对于这种情况，根就是全局最小值，直接输出根即可。 $2.$ $x \in root \bigcap root \in 1$ $|$ $x \notin root \bigcap x \ne root \bigcap x \notin (1 \to root)$ 对于这种情况，哪个为根对于 $ x ​$ 子树没有影响，所以直接查询。 $3.$ $x \in (1 \to root)$ 当 $ x $ 在它们所属的链上时，$ x $ 的子树就是除去往 $ root $ 方向的子树以外的所有子树。 所以把这些不去要的节点找出并去掉，就是答案了。 看下图，感性理解一下。 $ Code :$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl#define re register#define For(i, j, k) for(re int i = j; i &lt;= k; i++)#define foR(i, j, k) for(re int i = j; i &gt;= k; i--)using namespace std;typedef long long ll;const ll N = 100011;const ll inf = 0x3f3f3f3f3f3f;ll n, T, ID, lg[N], def[N];struct edge &#123; ll to, next;&#125; e[N &lt;&lt; 1];ll cnt, head[N];inline void add ( ll u, ll v ) &#123; e[++cnt].to = v, e[cnt].next = head[u], head[u] = cnt; e[++cnt].to = u, e[cnt].next = head[v], head[v] = cnt;&#125;namespace IO &#123; inline ll read() &#123; ll x = 0; bool f = 0; char ch = getchar(); for(; !isdigit( ch ); ch = getchar()) f^=( ch == '-' ); for(; isdigit( ch ); ch = getchar()) x = ( x &lt;&lt; 3 ) + ( x &lt;&lt; 1 ) + ( ch ^ 48 ); return f? -x: x; &#125; inline void write( ll x ) &#123; if( x &lt; 0 ) putchar( '-' ), x = -x; if( x &gt; 9 ) write( x / 10 ); putchar( x % 10 | 48 ); &#125; inline void wln( ll x ) &#123; write( x ); putchar( '\n' ); &#125;&#125;using namespace IO;namespace Chain_Tree &#123; ll fa[25][N], dep[N], size[N], Bigson[N]; inline void dfs1 ( ll u, ll fath ) &#123; fa[0][u] = fath; for ( re int i = 1; ( 1 &lt;&lt; i ) &lt;= dep[u]; i++ ) fa[i][u] = fa[i - 1][fa[i - 1][u]]; // 预处理倍增数组。 dep[u] = dep[fath] + 1, size[u] = 1; for ( re int i = head[u]; i; i = e[i].next ) if ( e[i].to != fath ) &#123; ll v = e[i].to; dfs1 ( v, u ); size[u] += size[v]; if ( size[v] &gt; size[Bigson[u]] ) Bigson[u] = v; &#125; &#125; ll tot = 0, id[N], rk[N], top[N]; inline void dfs2 ( ll u, ll now_top ) &#123; id[u] = ++tot, rk[tot] = u, top[u] = now_top; if ( !Bigson[u] ) return ; dfs2 ( Bigson[u], now_top ); for ( re int i = head[u]; i; i = e[i].next ) if ( e[i].to != fa[0][u] &amp;&amp; e[i].to != Bigson[u] ) dfs2 ( e[i].to, e[i].to ); &#125; &#125; // 树剖板子。 using namespace Chain_Tree;namespace Segment_Tree &#123; ll ans[N &lt;&lt; 2], tag[N &lt;&lt; 2]; inline void push_up ( ll p ) &#123; ans[p] = min ( ans[ls(p)], ans[rs(p)] ); &#125; inline void push_down ( ll p ) &#123; if ( tag[p] ) &#123; tag[ls(p)] = tag[rs(p)] = tag[p]; ans[ls(p)] = ans[rs(p)] = tag[p]; tag[p] = 0; &#125; // 修改元素答案为 tag 。 &#125; inline void build ( ll p, ll l, ll r ) &#123; if ( l == r ) &#123; ans[p] = def[rk[l]]; return ; &#125; build ( ls(p), l, mid ); build ( rs(p), mid + 1, r ); push_up (p); &#125; inline void update ( ll p, ll l, ll r, ll ul, ll ur, ll k ) &#123; if ( l &gt;= ul &amp;&amp; r &lt;= ur ) &#123; ans[p] = tag[p] = k; return ; &#125; push_down (p); if ( mid &gt;= ul ) update ( ls(p), l, mid, ul, ur, k ); if ( mid &lt; ur ) update ( rs(p), mid + 1, r, ul, ur, k ); push_up (p); &#125; inline ll query ( ll p, ll l, ll r, ll ul, ll ur ) &#123; if ( l &gt;= ul &amp;&amp; r &lt;= ur ) return ans[p]; push_down (p); ll res = inf; if ( mid &gt;= ul ) res = min ( res, query ( ls(p), l, mid, ul, ur ) ); if ( mid &lt; ur ) res = min ( res, query ( rs(p), mid + 1, r, ul, ur ) ); return res; &#125; &#125;using namespace Segment_Tree;inline void modify ( ll x, ll y, ll k ) &#123; while ( top[x] != top[y] ) &#123; if ( dep[top[x]] &lt; dep[top[y]] ) swap ( x, y ); update ( 1, 1, n, top[id[x]], id[x], k ); x = fa[0][top[x]]; &#125; if ( id[x] &gt; id[y] ) swap ( x, y ); update ( 1, 1, n, id[x], id[y], k );&#125;inline ll Find ( ll x, ll y ) &#123; For ( i, lg[y], 0 ) if ( y &gt;= ( 1 &lt;&lt; i ) ) y -= 1 &lt;&lt; i, x = fa[i][x]; return x;&#125; // 倍增找祖先。 ll u, v;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); n = read(), T = read(); lg[0] = -1; For ( i, 1, n ) lg[i] = lg[i &gt;&gt; 1] + 1; For ( i, 1, n - 1 ) u = read(), add ( u, read() ); For ( i, 1, n ) def[i] = read(); ID = read(); dfs1 ( 1, 0 ); dfs2 ( 1, 1 ); build ( 1, 1, n ); while ( T-- ) &#123; ll opt = read(); switch ( opt ) &#123; case 1: ID = read(); break; case 2: u = read(), v = read(), modify ( u, v, read() ); break; case 3: u = read(); if ( u == ID ) &#123; wln ( ans[1] ); break; &#125; if ( Find ( ID, dep[ID] - dep[u] ) == u ) &#123; v = Find ( ID, dep[ID] - dep[u] - 1 ); ll aa = query ( 1, 1, n, 1, id[v] - 1 ); ll aaa = ( id[u] + size[v] &lt;= n )? query ( 1, 1, n, id[v] + size[v], n ): inf; wln ( min ( aa, aaa ) ); &#125; else wln ( query ( 1, 1, n, id[u], id[u] + size[u] - 1 ) ); // 此处分类讨论三种情况。 &#125; // 重点。 &#125; return 0;&#125;/**/ 题目链接]]></content>
      <tags>
        <tag>Tree chain partition</tag>
      </tags>
  </entry>
</search>
