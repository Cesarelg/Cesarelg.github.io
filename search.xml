<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[A distant country]]></title>
    <url>%2F2019%2F03%2F20%2FA-distant-country%2F</url>
    <content type="text"><![CDATA[遥远的国度题解$Description$给出一棵树，需要支持换根、区间查询、区间修改等操作。 $Solution$除了换根操作，其他都是树链剖分板子。 对于换根操作，我们考虑先以一号节点为根节点做一次树剖，然后对于换根的操作分类讨论。 接下来以 $ root ​$ 表示目前的根节点， $ x ​$ 表示 $ x ​$ 子树。 $1.​$ $x == root​$ 对于这种情况，根就是全局最小值，直接输出根即可。 $2.$ $x \in root \bigcap root \in 1$ $|$ $x \notin root \bigcap x \ne root \bigcap x \notin (1 \to root)$ 对于这种情况，哪个为根对于 $ x ​$ 子树没有影响，所以直接查询。 $3.$ $x \in (1 \to root)$ 当 $ x $ 在它们所属的链上时，$ x $ 的子树就是除去往 $ root $ 方向的子树以外的所有子树。 所以把这些不去要的节点找出并去掉，就是答案了。 看下图，感性理解一下。 $ Code $123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl#define re register#define For(i, j, k) for(re int i = j; i &lt;= k; i++)#define foR(i, j, k) for(re int i = j; i &gt;= k; i--)using namespace std;typedef long long ll;const ll N = 100011;const ll inf = 0x3f3f3f3f3f3f;ll n, T, ID, lg[N], def[N];struct edge &#123; ll to, next;&#125; e[N &lt;&lt; 1];ll cnt, head[N];inline void add ( ll u, ll v ) &#123; e[++cnt].to = v, e[cnt].next = head[u], head[u] = cnt; e[++cnt].to = u, e[cnt].next = head[v], head[v] = cnt;&#125;namespace IO &#123; inline ll read() &#123; ll x = 0; bool f = 0; char ch = getchar(); for(; !isdigit( ch ); ch = getchar()) f^=( ch == '-' ); for(; isdigit( ch ); ch = getchar()) x = ( x &lt;&lt; 3 ) + ( x &lt;&lt; 1 ) + ( ch ^ 48 ); return f? -x: x; &#125; inline void write( ll x ) &#123; if( x &lt; 0 ) putchar( '-' ), x = -x; if( x &gt; 9 ) write( x / 10 ); putchar( x % 10 | 48 ); &#125; inline void wln( ll x ) &#123; write( x ); putchar( '\n' ); &#125;&#125;using namespace IO;namespace Chain_Tree &#123; ll fa[25][N], dep[N], size[N], Bigson[N]; inline void dfs1 ( ll u, ll fath ) &#123; fa[0][u] = fath; for ( re int i = 1; ( 1 &lt;&lt; i ) &lt;= dep[u]; i++ ) fa[i][u] = fa[i - 1][fa[i - 1][u]]; // 预处理倍增数组。 dep[u] = dep[fath] + 1, size[u] = 1; for ( re int i = head[u]; i; i = e[i].next ) if ( e[i].to != fath ) &#123; ll v = e[i].to; dfs1 ( v, u ); size[u] += size[v]; if ( size[v] &gt; size[Bigson[u]] ) Bigson[u] = v; &#125; &#125; ll tot = 0, id[N], rk[N], top[N]; inline void dfs2 ( ll u, ll now_top ) &#123; id[u] = ++tot, rk[tot] = u, top[u] = now_top; if ( !Bigson[u] ) return ; dfs2 ( Bigson[u], now_top ); for ( re int i = head[u]; i; i = e[i].next ) if ( e[i].to != fa[0][u] &amp;&amp; e[i].to != Bigson[u] ) dfs2 ( e[i].to, e[i].to ); &#125; &#125; // 树剖板子。 using namespace Chain_Tree;namespace Segment_Tree &#123; ll ans[N &lt;&lt; 2], tag[N &lt;&lt; 2]; inline void push_up ( ll p ) &#123; ans[p] = min ( ans[ls(p)], ans[rs(p)] ); &#125; inline void push_down ( ll p ) &#123; if ( tag[p] ) &#123; tag[ls(p)] = tag[rs(p)] = tag[p]; ans[ls(p)] = ans[rs(p)] = tag[p]; tag[p] = 0; &#125; // 修改元素答案为 tag 。 &#125; inline void build ( ll p, ll l, ll r ) &#123; if ( l == r ) &#123; ans[p] = def[rk[l]]; return ; &#125; build ( ls(p), l, mid ); build ( rs(p), mid + 1, r ); push_up (p); &#125; inline void update ( ll p, ll l, ll r, ll ul, ll ur, ll k ) &#123; if ( l &gt;= ul &amp;&amp; r &lt;= ur ) &#123; ans[p] = tag[p] = k; return ; &#125; push_down (p); if ( mid &gt;= ul ) update ( ls(p), l, mid, ul, ur, k ); if ( mid &lt; ur ) update ( rs(p), mid + 1, r, ul, ur, k ); push_up (p); &#125; inline ll query ( ll p, ll l, ll r, ll ul, ll ur ) &#123; if ( l &gt;= ul &amp;&amp; r &lt;= ur ) return ans[p]; push_down (p); ll res = inf; if ( mid &gt;= ul ) res = min ( res, query ( ls(p), l, mid, ul, ur ) ); if ( mid &lt; ur ) res = min ( res, query ( rs(p), mid + 1, r, ul, ur ) ); return res; &#125; &#125;using namespace Segment_Tree;inline void modify ( ll x, ll y, ll k ) &#123; while ( top[x] != top[y] ) &#123; if ( dep[top[x]] &lt; dep[top[y]] ) swap ( x, y ); update ( 1, 1, n, top[id[x]], id[x], k ); x = fa[0][top[x]]; &#125; if ( id[x] &gt; id[y] ) swap ( x, y ); update ( 1, 1, n, id[x], id[y], k );&#125;inline ll Find ( ll x, ll y ) &#123; For ( i, lg[y], 0 ) if ( y &gt;= ( 1 &lt;&lt; i ) ) y -= 1 &lt;&lt; i, x = fa[i][x]; return x;&#125; // 倍增找祖先。 ll u, v;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); n = read(), T = read(); lg[0] = -1; For ( i, 1, n ) lg[i] = lg[i &gt;&gt; 1] + 1; For ( i, 1, n - 1 ) u = read(), add ( u, read() ); For ( i, 1, n ) def[i] = read(); ID = read(); dfs1 ( 1, 0 ); dfs2 ( 1, 1 ); build ( 1, 1, n ); while ( T-- ) &#123; ll opt = read(); switch ( opt ) &#123; case 1: ID = read(); break; case 2: u = read(), v = read(), modify ( u, v, read() ); break; case 3: u = read(); if ( u == ID ) &#123; wln ( ans[1] ); break; &#125; if ( Find ( ID, dep[ID] - dep[u] ) == u ) &#123; v = Find ( ID, dep[ID] - dep[u] - 1 ); ll aa = query ( 1, 1, n, 1, id[v] - 1 ); ll aaa = ( id[u] + size[v] &lt;= n )? query ( 1, 1, n, id[v] + size[v], n ): inf; wln ( min ( aa, aaa ) ); &#125; else wln ( query ( 1, 1, n, id[u], id[u] + size[u] - 1 ) ); // 此处分类讨论三种情况。 &#125; // 重点。 &#125; return 0;&#125;/**/]]></content>
      <tags>
        <tag>Solution</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[slingshot]]></title>
    <url>%2F2019%2F03%2F20%2Fslingshot%2F</url>
    <content type="text"><![CDATA[题解$Slingshot$对于本题，我们进行分类讨论： $ 1. $ 对于这种情况，$x \to y​$ 包含了 $s \to t​$ ，所以此时的选择有两种： ① 先从 $s​$ 走到 $x​$ ，然后穿到 $y​$ ，再从 $y​$ 走到 $t​$ 。 ② 直接从 $s$ 走到 $t$ 。 然后我们 $yy$ 一下，如何用线段树维护多个 $x \to y$ 只选一个最优的 $x \to y$ 的情况。 显然，这是个线段树维护区间最小值裸题。 所以，由于我们根据 $x$ 端点排序，所以只需要将 ① 情况的路程插入线段树中的 $ y $ 节点的位置即可。 对于这种情况，路程就是$$ti + (s - x) + (y - t)$$在线段树中插入这个东东即可。 $ 2. ​$ 对于这种情况， $ s \to t $ 包含了 $ x \to y $ 的情况，所以路程就是$$ti + (x - s) + (t - y)$$$ 3. $ 对于这种情况， $ s \to t $ 包含了 $ x $ ，不包含 $ y $ ，所以路程就是$$ti + (s - x) + (t - y)$$$ 4. $ 与 $ 3 $ 同理，只是包含情况反一下，也就是$$ti + (x - s) + (y - t)$$离散化一下，四种情况各建一棵线段树就完了。 $ Code: $123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define debug(x) cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl#define ls(x) (x &lt;&lt; 1)#define rs(x) (x &lt;&lt; 1 | 1)#define mid ((l + r) &gt;&gt; 1)#define re register#define For(i, j, k) for(re int i = j; i &lt;= k; i++)#define foR(i, j, k) for(re int i = j; i &gt;= k; i--)using namespace std;typedef long long ll;const ll N = 200011;const ll inf = 0x3f3f3f3f3f3f3f;ll n, m, cnt, rep[N];struct node &#123; ll x, y, w, id;&#125; p[N];inline bool cmp ( node a, node b ) &#123; return a.x == b.x? a.x &lt; b.y: a.x &lt; b.x; &#125;namespace IO &#123; inline ll read() &#123; ll x = 0; bool f = 0; char ch = getchar(); for (; !isdigit (ch); ch = getchar()) f ^= ( ch == '-' ); for (; isdigit (ch); ch = getchar()) x = ( x &lt;&lt; 1 ) + ( x &lt;&lt; 3 ) + ( ch ^ 48 ); return f? -x: x; &#125; inline void write ( ll x ) &#123; if ( x &lt; 0 ) x = -x, putchar ( '-' ); if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125;&#125;using namespace IO;namespace Segment_Tree &#123; struct Tree &#123; ll mn; &#125; ans[N &lt;&lt; 2]; inline void push_up ( ll p ) &#123; ans[p].mn = min ( ans[ls(p)].mn, ans[rs(p)].mn ); &#125; inline void build ( ll p, ll l, ll r ) &#123; if ( l == r ) &#123; ans[p].mn = inf; return ; &#125; build ( ls(p), l, mid ); build ( rs(p), mid + 1, r ); push_up (p); &#125; inline void Insert ( ll p, ll l, ll r, ll x, ll k ) &#123; if ( l == r ) &#123; ans[p].mn = min ( k, ans[p].mn ); return ; &#125; if ( mid &gt;= x ) Insert ( ls(p), l, mid, x, k ); if ( mid &lt; x ) Insert ( rs(p), mid + 1, r, x, k ); push_up (p); &#125; inline ll Query ( ll p, ll l, ll r, ll ul, ll ur ) &#123; if ( l &gt;= ul &amp;&amp; r &lt;= ur ) return ans[p].mn; if ( mid &gt;= ur ) return Query ( ls(p), l, mid, ul, ur ); else if ( mid &lt; ul ) return Query ( rs(p), mid + 1, r, ul, ur ); else return min ( Query ( ls(p), l, mid, ul, ur ), Query ( rs(p), mid + 1, r, ul, ur ) ); &#125; &#125;using namespace Segment_Tree;ll u, v, w, s, t, _x[N], _y[N];int main () &#123; freopen ("ztn.in", "r", stdin); freopen ("ztn.out", "w", stdout); n = read(), m = read(); For ( i, 1, n ) &#123; u = read(), v = read(), w = read(); p[++cnt].x = u, p[cnt].y = v, p[cnt].w = w, p[cnt].id = 0; _x[cnt] = u, _y[cnt] =v; &#125; For ( i, 1, m ) &#123; s = read(), t = read(); p[++cnt].x = s, p[cnt].y = t, p[cnt].w = 0, p[cnt].id = i; _x[cnt] = s, _y[cnt] =t; rep[i] = abs ( s - t ); &#125; /* -----------------离散化----------------- */ sort ( p + 1, p + cnt + 1, cmp ); sort ( _x + 1, _x + cnt + 1 ); ll len = unique ( _x + 1, _x + cnt + 1 ) - _x - 1; For ( i, 1, cnt ) p[i].x = lower_bound ( _x + 1, _x + len + 1, p[i].x ) - _x; sort ( _y + 1, _y + cnt + 1 ); len = unique ( _y + 1, _y + cnt + 1 ) - _y - 1; For ( i, 1, cnt ) p[i].y = lower_bound ( _y + 1, _y + len + 1, p[i].y ) - _y; /* ---------------------------------- */ /* ----------------分类讨论------------------ */ build ( 1, 1, cnt ); For ( i, 1, cnt ) if ( !p[i].id ) Insert ( 1, 1, cnt, p[i].y, p[i].w -_x[p[i].x] - _y[p[i].y] ); else rep[p[i].id] = min ( rep[p[i].id], Query ( 1, 1, cnt, 1, p[i].y ) + _x[p[i].x] + _y[p[i].y] ); // x -&gt; y 包含 s ，不包含 t 。 build ( 1, 1, cnt ); For ( i, 1, cnt ) if ( !p[i].id ) Insert ( 1, 1, cnt, p[i].y, p[i].w -_x[p[i].x] + _y[p[i].y] ); else rep[p[i].id] = min ( rep[p[i].id], Query ( 1, 1, cnt, p[i].y, cnt ) + _x[p[i].x] - _y[p[i].y] ); // s -&gt; t 包含 x -&gt; y build ( 1, 1, cnt ); foR ( i, cnt, 1 ) if ( !p[i].id ) Insert ( 1, 1, cnt, p[i].y, p[i].w + _x[p[i].x] + _y[p[i].y] ); else rep[p[i].id] = min ( rep[p[i].id], Query ( 1, 1, cnt, p[i].y, cnt ) - _x[p[i].x] - _y[p[i].y] ); // x -&gt; y 包含 t ， 不包含 s 。 build ( 1, 1, cnt ); foR ( i, cnt, 1 ) if ( !p[i].id ) Insert ( 1, 1, cnt, p[i].y, p[i].w + _x[p[i].x] - _y[p[i].y] ); else rep[p[i].id] = min ( rep[p[i].id], Query ( 1, 1, cnt, 1, p[i].y ) - _x[p[i].x] + _y[p[i].y] ); // x -&gt; y 包含 s -&gt; t /* ---------------------------------- */ For ( i, 1, m ) wln ( rep[i] ); return 0;&#125;/*2 30 10 113 8 21 125 220 7*/ 另外，关于循环的问题为什么有两种正序，两种倒序呢？ 让我们再看一遍先前的例图： 前两个正序的： 后两个倒序的： 发现了吗，两者之间的奥秘。 留给读者自行证明。 从前面开始扫，由于 $ y $ 是排过序的，你插入的点就会在 $ s \to t $ 之间，否则有可能在外面，就是不优的，是错的。]]></content>
      <tags>
        <tag>Solution</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
