<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Park]]></title>
    <url>%2F2019%2F03%2F26%2FPark%2F</url>
    <content type="text"><![CDATA[$Park$$Description$123456789游乐园里新推出一个游戏——飞机驾驶体验。有*N*-1 个小朋友来玩这个游戏，他们排成长长的一列。这个游戏一共有 M 架“飞机”可供驾驶，每架飞机的使用时间都是有限制的，第 i 架“飞机”的使用时间是 si 分钟。 一开始所有“飞机”都是闲置着的，然后排队等候着的小朋友依次上“飞机”。如果有飞机闲置，则小朋友一定会上去玩(小朋友不会在意飞机使用的时间)；如果同时有多架“飞机”闲置着，小朋友一定会选择标号最小的那架。 现在你带着你的弟弟来到了游乐园，排到了最后一个位置。你想知道你弟弟会在哪架“飞机”上体验。 $Solution$考虑二分弟弟上飞机的时间。 $check$ 函数很好写，只需要将所有的 $s_i$ 在这么长时间内上去几个人算出来就好了。 二分出时间后，取时间减一， $n$ 与时间减一的差就是弟弟在这分钟上去飞机次序。 把所有在这一分钟满足条件的飞机取出，第 $n - res$ 即为答案。 $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;bits/stdc++.h&gt;#define debug(x) (cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl)#define re register#define For(i, j, k) for(re int i = j; i &lt;= k; i++)#define foR(i, j, k) for(re int i = j; i &gt;= k; i--)#define Cros(i, j, k) for(re int i = j; i; i = k)using namespace std;typedef long long ll;const ll N = 100011;const ll inf = 0x3f3f3f3f3f3f3f;/* 二分真**难调。 */ll n, m, s[N];ll t = 1, zz = 0, bei[N];namespace IO &#123; #define dd ch = getchar() inline ll read() &#123; ll x = 0; bool f = 0; char dd; for (; !isdigit (ch); dd) f ^= (ch == '-'); for (; isdigit (ch); dd) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); return f? -x: x; &#125; #undef dd inline void write ( ll x ) &#123; if ( x &lt; 0 ) x = -x, putchar ('-'); if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar (' '); &#125; inline void wln ( ll x ) &#123; write (x); putchar ('\n'); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x); wln (y); &#125; &#125;using namespace IO;namespace Subtask1 &#123; ll mn = inf; inline void main () &#123; For ( i, 1, m ) s[i] = read(), mn = min ( mn, s[i] ); zz = m; if ( n - 1 &lt;= m ) &#123; wln (n - 1); exit (0); &#125; while (1) &#123; t ++; For ( i, 1, m ) &#123; // debug (t % s[i]); if ( t % s[i] == 0 ) zz++; if ( zz == n ) &#123; wln (i); exit (0); &#125; &#125; &#125; &#125; &#125;namespace Subtask &#123; ll mx = 0, cnt = 0, alb[N]; inline bool check ( ll ss ) &#123; ll res = 0; For ( i, 1, m ) res += ss / s[i] + 1; return res &gt;= n; &#125; inline void main () &#123; For ( i, 1, m ) s[i] = read(), mx = max ( mx, s[i] ); ll l = 1, r = mx * n; while ( l &lt;= r ) &#123; ll Mid = ( l + r ) &gt;&gt; 1; check (Mid)? r = Mid - 1: l = Mid + 1; &#125; // 二分在第几分钟上飞机。// wln (l); ll aa = l, res = 0, ress = 0, albb; For ( i, 1, m ) res += aa / s[i] + 1; For ( i, 1, m ) ress += (aa - 1) / s[i] + 1; albb = n - ress;// debug (ress);// ress -= res; For ( i, 1, m ) if ( aa % s[i] == 0 ) alb[++cnt] = i;// For ( i, 0, cnt - 1 ) wln ( alb[i] ); wln ( alb [albb] ); &#125; &#125;int main () &#123; freopen("park.in", "r", stdin); freopen("park.out", "w", stdout); n = read(), m = read(); // ( n &lt;= 1000000 )? // Subtask1::main (); Subtask::main (); return 0; // Sherry, &#125;/*22 51 2 3 4 5431 51 2 3 4 5332 51 2 3 4 5433 51 2 3 4 51*/]]></content>
      <tags>
        <tag>two points answer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Super particle Cannon]]></title>
    <url>%2F2019%2F03%2F22%2FSuper-particle-Cannon%2F</url>
    <content type="text"><![CDATA[$Super$ $Particle$ $Cannon$$Description$求$$\sum_{i = 0}^{k} C_n^i \bmod 2333$$ $Solution$设$$f(n, k) = \sum_{i = 0}^{k} C_n^i$$即$$\sum_{i = 0}^{k}C_{n / p}^{i / p} \times C_{n \% p}^{i \% p}$$数论分块一下，此处将其分成 $p - 1$ 个块，许多数字同属一个块，就一起算掉。$$\sum_{i = 0}^{p - 1}C_{n \% p}^{i}C_{n / p}^{0} + \sum_{i = 0}^{p - 1}C_{n \% p}^{i}C_{n / p}^{1} + … + \sum_{i = 0}^{p - 1}C_{n \% p}^{i}C_{n / p}^{k / p - 1} + \sum_{i = 0}^{k \% p}C_{n \% p}^{i}C_{n / p}^{k / p}$$把 $\sum_{i = 0}^{p - 1}C_{n \% p}^{i}$ 提出来$$\sum_{i = 0}^{p - 1}C_{n \% p}^{i} \sum_{i = 0}^{k}C_{n / p}^{i / p - 1}$$也就是$$f(n \% p, p - 1) \times f(n / p, k / p - 1)$$最后一个不完整的块单独处理$$\sum_{i = 0}^{k \% p}C_{n \% p}^{i}$$即$$f(n \% p,k \% p)$$所以$$f(n, k) = f(n \% p, p - 1) \times f(n / p, k / p - 1) + C_{n / p}^{k / p} \times f(n \% p, k \% p)$$预处理组合数，套个 $Lucas$ 就完了。 $Code:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); i--)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll p = 2333;const ll N = 2345;const ll inf = 0x3f3f3f3f3f3f;ll T, n, k, res, C[N + 11][N + 11], f[N + 11][N + 11];namespace IO &#123; inline ll read() &#123; ll x = 0; bool f = 0; char ch = getchar(); for (; !isdigit (ch); ch = getchar()) f ^= (ch == '-'); for (; isdigit (ch); ch = getchar()) x = ( x &lt;&lt; 3 ) + ( x &lt;&lt; 1 ) + ( ch ^ 48 ); return f? -x: x; &#125; inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ( '-' ), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;inline ll Lucas ( ll n, ll m ) &#123; if ( n &lt; m ) return 0; if ( !m || n == m ) return 1; return C[n % p][m % p] * Lucas ( n / p, m / p ) % p;&#125;inline ll F ( ll n, ll k ) &#123; if ( k &lt; 0 ) return 0; if ( !n || !k ) return 1; if ( n &lt; p &amp;&amp; k &lt; p ) return f[n][k]; return ( F (n / p, k / p - 1) * f[n % p][p - 1] % p + Lucas ( n / p, k / p ) * f[n % p][k % p] % p ) % p;&#125;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); f[0][0] = C[0][0] = 1; For ( i, 1, N ) C[i][i] = C[i][0] = f[i][0] = 1; For ( i, 1, N ) For ( j, 1, i - 1 ) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % p; For ( i, 0, N ) For ( j, 1, N ) f[i][j] = ( C[i][j] + f[i][j - 1] ) % p; T = read(); while ( T-- ) n = read(), wln ( F (n, read()) ); return 0;&#125;/*35 510 71145 1432968763*/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
        <tag>Lucas</tag>
        <tag>数论分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Savage]]></title>
    <url>%2F2019%2F03%2F22%2FSavage%2F</url>
    <content type="text"><![CDATA[$Savage$$Description$给出 $n$ 个野人，初始在第 $C_i$ 个洞穴，每个人一年能走 $P_i$ 个洞穴，寿命是 $L_i$ 年，所有人在一个环上走，求最小满足所有人互不碰到的环的长度。 $Solution$由题意得，我们需要使 $C_{i} + P_i \times x \equiv C_j + P_j \times x \bmod M$ $(x &lt;=1, min(L_i, L_j))$ $|$ $x &gt; min(L_i, L_j)$ 无解。 考虑化简式子：$$(P_i - P_j) \times x \equiv C_j - C_i \pmod M$$移项，变成 $exgcd$ 方程组：$$(P_i - P_j) \times x + M \times y = C_j - C_i$$枚举 $M​$ ，解方程即可。 $Code:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); i--)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 111;const ll inf = 0x3f3f3f3f3f3f;ll n, mx, C[N], P[N], L[N];namespace IO &#123; inline ll read() &#123; ll x = 0; bool f = 0; char ch = getchar(); for (; !isdigit (ch); ch = getchar()) f ^= (ch == '-'); for (; isdigit (ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48); return f? -x: x; &#125; inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ('-'), x = -x; if ( x &gt; 9 ) write (x / 10); putchar (x % 10 | 48); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;inline ll gcd ( ll a, ll b ) &#123; return !b? a: gcd (b, a % b); &#125;inline void exgcd ( ll a, ll b, ll &amp;d, ll &amp;x, ll &amp;y ) &#123; if (b) &#123; exgcd (b, a % b, d, y, x); y -= a / b * x; &#125; else d = a, x = 1, y = 0; return ;&#125;inline bool check ( ll M ) &#123; For ( i, 1, n ) For ( j, i + 1, n ) &#123; ll d, a = P[i] - P[j], b = M, v = C[j] - C[i], x = 0, y = 0, GCD = gcd ( a, b ); if ( v % GCD == 0 ) &#123; a /= GCD, b /= GCD, v /= GCD; exgcd ( a, b, d, x, y ); b = b &lt; 0? -b: b; x = (x * v % b + b) % b; x = !x? x + b: x; if ( x &lt;= min ( L[i], L[j] ) ) return false; &#125; &#125; return 1;&#125;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); n = read(); For ( i, 1, n ) mx = max (mx, C[i] = read()), P[i] = read(), L[i] = read(); for (re int i = mx; ; i++) if ( check (i) ) return wln (i), 0; return 0;&#125;/*31 3 42 7 33 2 16*/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
        <tag>exgcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Multiplicative inverse]]></title>
    <url>%2F2019%2F03%2F22%2FMultiplicative-inverse%2F</url>
    <content type="text"><![CDATA[$linear$ $inverse$ $element$$Descirption$给出 $k​$ ，求它的逆元。 $Solution$设$$a \times k + b = p,{b \times inv[b]}\equiv1\pmod p$$变式，得$$b = p - a \times k,{(p - a \times k) \times inv[b]}\equiv1\pmod p$$ 拆括号，得$${p \times inv[b] - a \times k \times inv[b]}\equiv1\pmod p$$即$${-a \times k \times inv[b]}\equiv1\pmod p$$观察$$a \times k + b = p$$两边同是对 $k$ 取模，得$$b = p \bmod k$$故有$$a = p \div k$$代入原式，得$${-(p / k) \times inv[p \bmod k] \times k}\equiv 1 \pmod p$$即$${-(p / k) \times inv[p \bmod k]} \equiv inv[k] \pmod p$$ 也就是$${(p-p / k) \times inv[p \bmod k]} \equiv inv[k] \pmod p$$ $Code:$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl#define re register#define For(i, j, k) for(re int i = j; i &lt;= k; i++)#define foR(i, j, k) for(re int i = j; i &gt;= k; i--)using namespace std;typedef long long ll;const ll N = 200011;const ll inf = 0x3f3f3f3f3f3f;ll n, p, f[N];namespace IO &#123; inline ll read() &#123; ll x = 0; bool f = 0; char ch = getchar(); for(; !isdigit( ch ); ch = getchar()) f^=( ch == '-' ); for(; isdigit( ch ); ch = getchar()) x = ( x &lt;&lt; 3 ) + ( x &lt;&lt; 1 ) + ( ch ^ 48 ); return f? -x: x; &#125; inline void write( ll x ) &#123; if( x &lt; 0 ) putchar( '-' ), x = -x; if( x &gt; 9 ) write( x / 10 ); putchar( x % 10 | 48 ); &#125; inline void wln( ll x ) &#123; write( x ); putchar( '\n' ); &#125;&#125;using namespace IO;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); n = read(), p = read(); f[1] = 1; For ( i, 2, n ) f[i] = ( p - p / i ) * f[p % i] % p; For ( i, 1, n ) wln ( f[i] ); return 0;&#125;/**/]]></content>
      <tags>
        <tag>math</tag>
        <tag>Study Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SmartYanzi]]></title>
    <url>%2F2019%2F03%2F21%2FSmartYanzi%2F</url>
    <content type="text"><![CDATA[$Smart$ $Yanzi$$Description$给你一个数 $S$ ，求有多少数的约数和等于 $S$ 。 $Solution$对于一个数 $S$ ，根据算数基本定理，有分解式：$$S = p_1^{a_1}p_2^{a_2}p_3^{a_3}…p_n^{a_n}$$所以约数和就是$$sum = \prod_{i = 1}^{n}\sum_{j=0}^{a_i}p_i^j$$由于 $S&lt;=2*10^9$ ，考虑枚举 $S$ 的所有因子，先筛出 $\sqrt{S}$ 以内的质数，然后枚举 $p_i$ ，对于每个 $p_i$ 枚举 $a_i$ ，爆搜，如果将 $S$ 分解成功，答案 $ + 1$ 。 同时，如果 $S - 1$ 是一个质数，且 $&gt;=$ 当前搜的 $p_i$ ，答案也要 $ + 1$ ，因为 $S - 1$ 也是此时构造出的数的因子。 其实我们是先把质因子全部取出来，然后找所有的乘起来的可能，对于每种可能都枚举它是否成立。 就是把 $S$ 拆掉，然后再拼回去。 $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl#define re register#define For(i, j, k) for(re int i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re int i = (j); i &gt;= (k); i--)#define Cross(i, j, k) for(re int i = (j); i; i = (k))using namespace std;typedef long long ll;const ll N = 100011;const ll inf = 0x3f3f3f3f3f3f;ll S, tot = 0, di[N &lt;&lt; 2];namespace IO &#123; inline ll read() &#123; ll x = 0; bool f = 0; char ch = getchar(); for (; !isdigit (ch); ch = getchar()) f^= (ch == '-'); for (; isdigit (ch); ch = getchar()) x = ( x &lt;&lt; 3 ) + ( x &lt;&lt; 1 ) + ( ch ^ 48 ); return f? -x: x; &#125; inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ( '-' ), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125; inline void wlnn ( ll x, ll y ) &#123; wrn (x), wln (y); &#125;&#125;using namespace IO;ll cnt, pr[N], vis[N];inline void Init () &#123; For ( i, 2, N ) &#123; if ( !vis[i] ) pr[++cnt] = i; for ( re int j = 1; j &lt;= cnt &amp;&amp; i * pr[j] &lt;= N; j++ ) &#123; vis[i * pr[j]] = 1; if ( i % pr[j] == 0 ) break; &#125; &#125;&#125; // 预处理质数。 inline bool check ( ll n ) &#123; if ( n == 1 ) return 0; if ( n &lt;= N ) return !vis[n]; for ( re int i = 1; pr[i] * pr[i] &lt;= n; i++ ) if ( n % pr[i] == 0 ) return 0; return 1;&#125; // 判断质数。 inline void dfs ( ll now, ll x, ll y ) &#123; // x 表示当前用到第几个质数，y 表示当前搜出的数。 if ( now == 1 ) &#123; di[++tot] = y; return ; &#125; // 满足答案。 if ( now - 1 &gt;= pr[x] &amp;&amp; check ( now - 1 ) ) di[++tot] = y * ( now - 1 ); /* 如果当前数能表示成一个质数加一与一的乘积，那么就会是答案，只需要将 当前算出的答案乘上它就是满足条件的答案。 */ ll p, temp; for ( re int i = x; pr[i] * pr[i] &lt;= now; i++ ) &#123; temp = pr[i], p = pr[i] + 1; for (; p &lt;= now; temp *= pr[i], p += temp) if ( now % p == 0 ) dfs ( now / p, i + 1, y * temp ); &#125; // 枚举符合题意的因子。&#125;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); Init (); while ( cin &gt;&gt; S ) &#123; tot = 0; memset ( di, 0, sizeof ( di ) ); dfs ( S, 1ll, 1ll ); sort ( di + 1, di + tot + 1 ); // 从小到大输出。 wln (tot); For ( i, 1, tot - 1 ) wrn ( di[i] ); if (tot) wln ( di[tot] ); &#125; return 0;&#125;/*4220 26 41*/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sakura]]></title>
    <url>%2F2019%2F03%2F21%2FSakura%2F</url>
    <content type="text"><![CDATA[$Sakura$$Description$求 $\frac{1}{x} + \frac{1}{y} = \frac{1}{n!}​$ 的答案方案个数。 $Solution$设$$x = n! - a, y = n! - b, n = n!$$代入，得$$\frac{2n - a - b}{(n - a)(n - b)} = \frac{1}{n}$$化简，移项，得$$2n^2 - (a + b)n = n^2 - (a + b)n + ab$$故有$$ab = n^2$$筛出 $n^2$ 的因子即可。 $Code:$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;//#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )//#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl#define re register#define For(i, j, k) for(re ll i = (j); i &lt;= (k); i++)#define foR(i, j, k) for(re ll i = (j); i &gt;= (k); i--)#define cross(i, k) for(re int i = head[k]; i; i = e[i].next)using namespace std;typedef long long ll;const ll N = 2000011;const ll p = 1e9 + 7;const ll inf = 0x3f3f3f3f3f3f;ll n;namespace IO &#123; inline ll read() &#123; ll x = 0; bool f = 0; char ch = getchar(); for (; !isdigit (ch); ch = getchar()) f^= (ch == '-'); for (; isdigit (ch); ch = getchar()) x = ( x &lt;&lt; 3 ) + ( x &lt;&lt; 1 ) + ( ch ^ 48 ); return f? -x: x; &#125; inline void write( ll x ) &#123; if ( x &lt; 0 ) putchar ( '-' ), x = -x; if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wrn ( ll x ) &#123; write (x); putchar ( ' ' ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125;&#125;using namespace IO;ll ans = 1, cnt, c[N], pr[N], vis[N];inline void Init () &#123; For ( i, 2, n ) &#123; if ( !vis[i] ) vis[i] = pr[++cnt] = i; for ( re int j = 1; j &lt;= cnt &amp;&amp; i * pr[j] &lt;= n; j++ ) &#123; if ( pr[j] &gt; vis[i] ) break; vis[i * pr[j]] = pr[j]; &#125; &#125;&#125;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); n = read(); Init (); For ( i, 1, cnt ) &#123; ll P = pr[i]; for ( re ll j = P; j &lt;= n; j *= P ) c[i] += n / j; c[i] %= p; // 直接分解质因数。 &#125; For ( i, 1, cnt ) ans = ans * (c[i] * 2 + 1) % p; return wln ( ans ), 0;&#125;/*1439*/ 题目链接]]></content>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[slingshot]]></title>
    <url>%2F2019%2F03%2F18%2Fslingshot%2F</url>
    <content type="text"><![CDATA[题解$Slingshot$对于本题，我们进行分类讨论： $ 1. ​$ 对于这种情况，$x \to y​$ 包含了 $s \to t​$ ，所以此时的选择有两种： ① 先从 $s$ 走到 $x$ ，然后穿到 $y$ ，再从 $y$ 走到 $t$ 。 ② 直接从 $s$ 走到 $t$ 。 然后我们 $yy$ 一下，如何用线段树维护多个 $x \to y$ 只选一个最优的 $x \to y$ 的情况。 显然，这是个线段树维护区间最小值裸题。 所以，由于我们根据 $x$ 端点排序，所以只需要将 ① 情况的路程插入线段树中的 $ y $ 节点的位置即可。 对于这种情况，路程就是$$ti + (s - x) + (y - t)$$在线段树中插入这个东东即可。 $ 2. $ 对于这种情况， $ s \to t $ 包含了 $ x \to y $ 的情况，所以路程就是$$ti + (x - s) + (t - y)$$$ 3. $ 对于这种情况， $ s \to t $ 包含了 $ x $ ，不包含 $ y $ ，所以路程就是$$ti + (s - x) + (t - y)$$$ 4. $ 与 $ 3 $ 同理，只是包含情况反一下，也就是$$ti + (x - s) + (y - t)$$离散化一下，四种情况各建一棵线段树就完了。 $ Code: $123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;#define debug(x) cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl#define ls(x) (x &lt;&lt; 1)#define rs(x) (x &lt;&lt; 1 | 1)#define mid ((l + r) &gt;&gt; 1)#define re register#define For(i, j, k) for(re int i = j; i &lt;= k; i++)#define foR(i, j, k) for(re int i = j; i &gt;= k; i--)using namespace std;typedef long long ll;const ll N = 200011;const ll inf = 0x3f3f3f3f3f3f3f;ll n, m, cnt, rep[N];struct node &#123; ll x, y, w, id;&#125; p[N];inline bool cmp ( node a, node b ) &#123; return a.x == b.x? a.x &lt; b.y: a.x &lt; b.x; &#125;namespace IO &#123; inline ll read() &#123; ll x = 0; bool f = 0; char ch = getchar(); for (; !isdigit (ch); ch = getchar()) f ^= ( ch == '-' ); for (; isdigit (ch); ch = getchar()) x = ( x &lt;&lt; 1 ) + ( x &lt;&lt; 3 ) + ( ch ^ 48 ); return f? -x: x; &#125; inline void write ( ll x ) &#123; if ( x &lt; 0 ) x = -x, putchar ( '-' ); if ( x &gt; 9 ) write ( x / 10 ); putchar ( x % 10 | 48 ); &#125; inline void wln ( ll x ) &#123; write (x); putchar ( '\n' ); &#125;&#125;using namespace IO;namespace Segment_Tree &#123; struct Tree &#123; ll mn; &#125; ans[N &lt;&lt; 2]; inline void push_up ( ll p ) &#123; ans[p].mn = min ( ans[ls(p)].mn, ans[rs(p)].mn ); &#125; inline void build ( ll p, ll l, ll r ) &#123; if ( l == r ) &#123; ans[p].mn = inf; return ; &#125; build ( ls(p), l, mid ); build ( rs(p), mid + 1, r ); push_up (p); &#125; inline void Insert ( ll p, ll l, ll r, ll x, ll k ) &#123; if ( l == r ) &#123; ans[p].mn = min ( k, ans[p].mn ); return ; &#125; if ( mid &gt;= x ) Insert ( ls(p), l, mid, x, k ); if ( mid &lt; x ) Insert ( rs(p), mid + 1, r, x, k ); push_up (p); &#125; inline ll Query ( ll p, ll l, ll r, ll ul, ll ur ) &#123; if ( l &gt;= ul &amp;&amp; r &lt;= ur ) return ans[p].mn; if ( mid &gt;= ur ) return Query ( ls(p), l, mid, ul, ur ); else if ( mid &lt; ul ) return Query ( rs(p), mid + 1, r, ul, ur ); else return min ( Query ( ls(p), l, mid, ul, ur ), Query ( rs(p), mid + 1, r, ul, ur ) ); &#125; &#125;using namespace Segment_Tree;ll u, v, w, s, t, _x[N], _y[N];int main () &#123; freopen ("ztn.in", "r", stdin); freopen ("ztn.out", "w", stdout); n = read(), m = read(); For ( i, 1, n ) &#123; u = read(), v = read(), w = read(); p[++cnt].x = u, p[cnt].y = v, p[cnt].w = w, p[cnt].id = 0; _x[cnt] = u, _y[cnt] =v; &#125; For ( i, 1, m ) &#123; s = read(), t = read(); p[++cnt].x = s, p[cnt].y = t, p[cnt].w = 0, p[cnt].id = i; _x[cnt] = s, _y[cnt] =t; rep[i] = abs ( s - t ); &#125; /* -----------------离散化----------------- */ sort ( p + 1, p + cnt + 1, cmp ); sort ( _x + 1, _x + cnt + 1 ); ll len = unique ( _x + 1, _x + cnt + 1 ) - _x - 1; For ( i, 1, cnt ) p[i].x = lower_bound ( _x + 1, _x + len + 1, p[i].x ) - _x; sort ( _y + 1, _y + cnt + 1 ); len = unique ( _y + 1, _y + cnt + 1 ) - _y - 1; For ( i, 1, cnt ) p[i].y = lower_bound ( _y + 1, _y + len + 1, p[i].y ) - _y; /* ---------------------------------- */ /* ----------------分类讨论------------------ */ build ( 1, 1, cnt ); For ( i, 1, cnt ) if ( !p[i].id ) Insert ( 1, 1, cnt, p[i].y, p[i].w -_x[p[i].x] - _y[p[i].y] ); else rep[p[i].id] = min ( rep[p[i].id], Query ( 1, 1, cnt, 1, p[i].y ) + _x[p[i].x] + _y[p[i].y] ); // x -&gt; y 包含 s ，不包含 t 。 build ( 1, 1, cnt ); For ( i, 1, cnt ) if ( !p[i].id ) Insert ( 1, 1, cnt, p[i].y, p[i].w -_x[p[i].x] + _y[p[i].y] ); else rep[p[i].id] = min ( rep[p[i].id], Query ( 1, 1, cnt, p[i].y, cnt ) + _x[p[i].x] - _y[p[i].y] ); // s -&gt; t 包含 x -&gt; y build ( 1, 1, cnt ); foR ( i, cnt, 1 ) if ( !p[i].id ) Insert ( 1, 1, cnt, p[i].y, p[i].w + _x[p[i].x] + _y[p[i].y] ); else rep[p[i].id] = min ( rep[p[i].id], Query ( 1, 1, cnt, p[i].y, cnt ) - _x[p[i].x] - _y[p[i].y] ); // x -&gt; y 包含 t ， 不包含 s 。 build ( 1, 1, cnt ); foR ( i, cnt, 1 ) if ( !p[i].id ) Insert ( 1, 1, cnt, p[i].y, p[i].w + _x[p[i].x] - _y[p[i].y] ); else rep[p[i].id] = min ( rep[p[i].id], Query ( 1, 1, cnt, 1, p[i].y ) - _x[p[i].x] + _y[p[i].y] ); // x -&gt; y 包含 s -&gt; t /* ---------------------------------- */ For ( i, 1, m ) wln ( rep[i] ); return 0;&#125;/*2 30 10 113 8 21 125 220 7*/ 另外，关于循环的问题为什么有两种正序，两种倒序呢？ 让我们再看一遍先前的例图： 前两个正序的： 后两个倒序的： 发现了吗，两者之间的奥秘。 留给读者自行证明。 从前面开始扫，由于 $ y $ 是排过序的，你插入的点就会在 $ s \to t $ 之间，否则有可能在外面，就是不优的，是错的。 题目链接]]></content>
      <tags>
        <tag>category talk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A distant country]]></title>
    <url>%2F2019%2F03%2F15%2FA-distant-country%2F</url>
    <content type="text"><![CDATA[遥远的国度题解$Description$给出一棵树，需要支持换根、区间查询、区间修改等操作。 $Solution$除了换根操作，其他都是树链剖分板子。 对于换根操作，我们考虑先以一号节点为根节点做一次树剖，然后对于换根的操作分类讨论。 接下来以 $ root ​$ 表示目前的根节点， $ x ​$ 表示 $ x ​$ 子树。 $1.​$ $x == root​$ 对于这种情况，根就是全局最小值，直接输出根即可。 $2.$ $x \in root \bigcap root \in 1$ $|$ $x \notin root \bigcap x \ne root \bigcap x \notin (1 \to root)$ 对于这种情况，哪个为根对于 $ x ​$ 子树没有影响，所以直接查询。 $3.$ $x \in (1 \to root)$ 当 $ x $ 在它们所属的链上时，$ x $ 的子树就是除去往 $ root $ 方向的子树以外的所有子树。 所以把这些不去要的节点找出并去掉，就是答案了。 看下图，感性理解一下。 $ Code :$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;//#include"Bignum/bignum.h"//#define lll bignum#define ls(x) ( x &lt;&lt; 1 )#define rs(x) ( x &lt;&lt; 1 | 1 )#define mid ( ( l + r ) &gt;&gt; 1 )#define lowbit(x) ( x &amp; -x )#define debug(x) cout &lt;&lt; "#x = " &lt;&lt; x &lt;&lt; endl#define re register#define For(i, j, k) for(re int i = j; i &lt;= k; i++)#define foR(i, j, k) for(re int i = j; i &gt;= k; i--)using namespace std;typedef long long ll;const ll N = 100011;const ll inf = 0x3f3f3f3f3f3f;ll n, T, ID, lg[N], def[N];struct edge &#123; ll to, next;&#125; e[N &lt;&lt; 1];ll cnt, head[N];inline void add ( ll u, ll v ) &#123; e[++cnt].to = v, e[cnt].next = head[u], head[u] = cnt; e[++cnt].to = u, e[cnt].next = head[v], head[v] = cnt;&#125;namespace IO &#123; inline ll read() &#123; ll x = 0; bool f = 0; char ch = getchar(); for(; !isdigit( ch ); ch = getchar()) f^=( ch == '-' ); for(; isdigit( ch ); ch = getchar()) x = ( x &lt;&lt; 3 ) + ( x &lt;&lt; 1 ) + ( ch ^ 48 ); return f? -x: x; &#125; inline void write( ll x ) &#123; if( x &lt; 0 ) putchar( '-' ), x = -x; if( x &gt; 9 ) write( x / 10 ); putchar( x % 10 | 48 ); &#125; inline void wln( ll x ) &#123; write( x ); putchar( '\n' ); &#125;&#125;using namespace IO;namespace Chain_Tree &#123; ll fa[25][N], dep[N], size[N], Bigson[N]; inline void dfs1 ( ll u, ll fath ) &#123; fa[0][u] = fath; for ( re int i = 1; ( 1 &lt;&lt; i ) &lt;= dep[u]; i++ ) fa[i][u] = fa[i - 1][fa[i - 1][u]]; // 预处理倍增数组。 dep[u] = dep[fath] + 1, size[u] = 1; for ( re int i = head[u]; i; i = e[i].next ) if ( e[i].to != fath ) &#123; ll v = e[i].to; dfs1 ( v, u ); size[u] += size[v]; if ( size[v] &gt; size[Bigson[u]] ) Bigson[u] = v; &#125; &#125; ll tot = 0, id[N], rk[N], top[N]; inline void dfs2 ( ll u, ll now_top ) &#123; id[u] = ++tot, rk[tot] = u, top[u] = now_top; if ( !Bigson[u] ) return ; dfs2 ( Bigson[u], now_top ); for ( re int i = head[u]; i; i = e[i].next ) if ( e[i].to != fa[0][u] &amp;&amp; e[i].to != Bigson[u] ) dfs2 ( e[i].to, e[i].to ); &#125; &#125; // 树剖板子。 using namespace Chain_Tree;namespace Segment_Tree &#123; ll ans[N &lt;&lt; 2], tag[N &lt;&lt; 2]; inline void push_up ( ll p ) &#123; ans[p] = min ( ans[ls(p)], ans[rs(p)] ); &#125; inline void push_down ( ll p ) &#123; if ( tag[p] ) &#123; tag[ls(p)] = tag[rs(p)] = tag[p]; ans[ls(p)] = ans[rs(p)] = tag[p]; tag[p] = 0; &#125; // 修改元素答案为 tag 。 &#125; inline void build ( ll p, ll l, ll r ) &#123; if ( l == r ) &#123; ans[p] = def[rk[l]]; return ; &#125; build ( ls(p), l, mid ); build ( rs(p), mid + 1, r ); push_up (p); &#125; inline void update ( ll p, ll l, ll r, ll ul, ll ur, ll k ) &#123; if ( l &gt;= ul &amp;&amp; r &lt;= ur ) &#123; ans[p] = tag[p] = k; return ; &#125; push_down (p); if ( mid &gt;= ul ) update ( ls(p), l, mid, ul, ur, k ); if ( mid &lt; ur ) update ( rs(p), mid + 1, r, ul, ur, k ); push_up (p); &#125; inline ll query ( ll p, ll l, ll r, ll ul, ll ur ) &#123; if ( l &gt;= ul &amp;&amp; r &lt;= ur ) return ans[p]; push_down (p); ll res = inf; if ( mid &gt;= ul ) res = min ( res, query ( ls(p), l, mid, ul, ur ) ); if ( mid &lt; ur ) res = min ( res, query ( rs(p), mid + 1, r, ul, ur ) ); return res; &#125; &#125;using namespace Segment_Tree;inline void modify ( ll x, ll y, ll k ) &#123; while ( top[x] != top[y] ) &#123; if ( dep[top[x]] &lt; dep[top[y]] ) swap ( x, y ); update ( 1, 1, n, top[id[x]], id[x], k ); x = fa[0][top[x]]; &#125; if ( id[x] &gt; id[y] ) swap ( x, y ); update ( 1, 1, n, id[x], id[y], k );&#125;inline ll Find ( ll x, ll y ) &#123; For ( i, lg[y], 0 ) if ( y &gt;= ( 1 &lt;&lt; i ) ) y -= 1 &lt;&lt; i, x = fa[i][x]; return x;&#125; // 倍增找祖先。 ll u, v;int main() &#123;// freopen(".in", "r", stdin);// freopen(".out", "w", stdout); n = read(), T = read(); lg[0] = -1; For ( i, 1, n ) lg[i] = lg[i &gt;&gt; 1] + 1; For ( i, 1, n - 1 ) u = read(), add ( u, read() ); For ( i, 1, n ) def[i] = read(); ID = read(); dfs1 ( 1, 0 ); dfs2 ( 1, 1 ); build ( 1, 1, n ); while ( T-- ) &#123; ll opt = read(); switch ( opt ) &#123; case 1: ID = read(); break; case 2: u = read(), v = read(), modify ( u, v, read() ); break; case 3: u = read(); if ( u == ID ) &#123; wln ( ans[1] ); break; &#125; if ( Find ( ID, dep[ID] - dep[u] ) == u ) &#123; v = Find ( ID, dep[ID] - dep[u] - 1 ); ll aa = query ( 1, 1, n, 1, id[v] - 1 ); ll aaa = ( id[u] + size[v] &lt;= n )? query ( 1, 1, n, id[v] + size[v], n ): inf; wln ( min ( aa, aaa ) ); &#125; else wln ( query ( 1, 1, n, id[u], id[u] + size[u] - 1 ) ); // 此处分类讨论三种情况。 &#125; // 重点。 &#125; return 0;&#125;/**/ 题目链接]]></content>
      <tags>
        <tag>Tree chain partition</tag>
      </tags>
  </entry>
</search>
